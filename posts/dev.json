{
    "rss": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<rss version=\"2.0\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:content=\"http://purl.org/rss/1.0/modules/content/\">\n    <channel>\n        <title>Lau de Bugs' Blog</title>\n        <link>https://www.laudebugs.me/api/rss</link>\n        <description>Life and Software Development Blog</description>\n        <lastBuildDate>Fri, 12 Nov 2021 19:49:33 GMT</lastBuildDate>\n        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>\n        <generator>awesome</generator>\n        <language>en</language>\n        <image>\n            <title>Lau de Bugs' Blog</title>\n            <url>https://www.laudebugs.me/images/logos/logo_light.png</url>\n            <link>https://www.laudebugs.me/api/rss</link>\n        </image>\n        <copyright>All rights reserved 2021, Lau de Bugs</copyright>\n        <category>github</category>\n        <category>api</category>\n        <category>database</category>\n        <category>express</category>\n        <category>graphql</category>\n        <category>typescript</category>\n        <category>lighthouse</category>\n        <category>node.js</category>\n        <category>python</category>\n        <item>\n            <title><![CDATA[Using your GitHub Repository as a Database]]></title>\n            <link>https://www.laudebugs.me/dev/using-your-github-repository-as-a-database</link>\n            <guid>https://www.laudebugs.me/dev/using-your-github-repository-as-a-database</guid>\n            <pubDate>Mon, 01 Mar 2021 00:00:00 GMT</pubDate>\n            <description><![CDATA[You don't have to look far for somewhere to store your content. GitHub is a great place to store your content. Together with the GitHub API, you can use GitHub make this happen.]]></description>\n            <content:encoded><![CDATA[<h1 id=\"how-to-use-your-repo-as-a-database-with-the-github-graphql-api\">How To: Use your Repo as a Database with the Github GraphQL API</h1>\n<blockquote>\n<p>You can sort of use your Github repository as a database for your blog posts by leveraging the Github <a href=\"https://docs.github.com/en/graphql\">Graph QL API</a> üò±.</p>\n</blockquote>\n<h2 id=\"motivation\">Motivation</h2>\n<p>The Github GraphQL API provides a lot more capabilities than I can cover in one <em>snack</em>.</p>\n<p>However, in searching for a way to share the small lessons that I pick up week in week out, I knew that publishing through <a href=\"https://www.contentful.com/\">Contentful</a>, which it the CMS, I use for the main content in my blog site, was a little too much to share easily and quicly.\nPosting on Github and sharing that as <a href=\"https://gist.github.com/lbugasu\">gists</a> seemed like I would be writing too much for a gist that is supposed to be a short code snippet - which was the original title of this section. Although <a href=\"https://gist.github.com/MichaelCurrin/6777b91e6374cdb5662b64b8249070ea\">MichaelCurrin</a> proves me otherwise! His article is what got me goint in the first place!</p>\n<h2 id=\"querying-the-graphql-api-for-posts\">Querying the GraphQL API for posts.</h2>\n<p>In order to use the Github GraphQL API, you can either use the <a href=\"https://docs.github.com/en/graphql/overview/explorer\">API explorer</a> by logging in through your github account, use an api testing tool like <a href=\"https://support.insomnia.rest/article/61-graphql\">Insomnia</a>, or you can use it programmatically.</p>\n<p>Since I was using the Apollo Graph QL library to query my backend - that helps me manage comments and likes, I began to do a little research on how to query the Github GraphQL API. I will link the articles below.\nThis <a href=\"https://stackoverflow.com/questions/58576940/how-to-handle-authorization-header-with-apollo-graphql\">stack overflow</a> answered how to add an authorization header to an Apollo Client Query.</p>\n<h2 id=\"the-query\">The Query</h2>\n<p>We will be using writing our query in a node.js environment using both <a href=\"https://github.com/apollographql/apollo-client\">Apollo Client</a> and <a href=\"https://github.com/axios/axios\">Axios</a></p>\n<h3 id=\"1-obtain-your-github-public-access-token\">1. Obtain your github public access token</h3>\n<p>The only permission you need for this task is <code>public_repo</code> under <code>repo</code>:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> repo<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> public_repo</li>\n</ul>\n</li>\n</ul>\n<p>Give your token a name and will look something like this:</p>\n<pre><code class=\"language-txt\">89fdd35bcd40787b519e97462cec0f9975a66a58\n</code></pre>\n<p>Note the token above is revoked and you&#39;ll need to generate yours. Once you&#39;re done, we&#39;re ready for the next step!</p>\n<h3 id=\"2-querying-the-repo\">2. Querying the repo</h3>\n<p>In my case, I will be looking for files in my repository called <code>articles</code>. If you&#39;d like to use your own repository, simply make note of your repository name.</p>\n<h3 id=\"using-the-apollo-client\">Using the Apollo Client</h3>\n<ol>\n<li><p>Install the Apollo client</p>\n<pre><code class=\"language-bash\">npm install @apollo/client graphql\n</code></pre>\n</li>\n<li><p>Working in your js file, import the Apollo client and a few methods that we will make use of:</p>\n<pre><code class=\"language-js\">import { ApolloClient, InMemoryCache, gql, ApolloLink, HttpLink } from &#39;@apollo/client&#39;\n</code></pre>\n</li>\n<li><p>Initialize a new apollo client with the github graphQL endpoint and your token</p>\n<pre><code class=\"language-js\">const token = &#39;89fdd35bcd40787b519e97462cec0f9975a66a58&#39;\n\nconst endpoint = &#39;https://api.github.com/graphql&#39;\n\n// Add the toke to the header of your client for all your requests\nconst githubLClient = new ApolloClient({\n  uri: endpoint,\n  headers: {\n    authorization: `Bearer ${token}`\n  },\n  cache: new InMemoryCache({\n    addTypename: false\n  })\n})\n</code></pre>\n</li>\n<li><p>Make the query\nI referenced github user <a href=\"https://gist.github.com/int128/b0e75e3043c8a33808cea0089d988ed3\">int128&#39;s gist</a> for the structure of the graphQl query:</p>\n<pre><code class=\"language-js\">let request = await githubClient.query({\n  query: gql`\n    {\n      repository(owner: &quot;lbugasu&quot;, name: &quot;articles&quot;) {\n        defaultBranchRef {\n          target {\n            ... on Commit {\n              file(path: &quot;/&quot;) {\n                type\n                object {\n                  ... on Tree {\n                    entries {\n                      name\n                      object {\n                        ... on Blob {\n                          text\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  `\n})\n</code></pre>\n</li>\n<li><p>Parse your output to obtain the file&#39;s contents.\nBy making this same query on Github&#39;s GraphQL explorer, the data returned, which is essentially a json object, at the time of writing this, looks like this:</p>\n<pre><code class=\"language-json\">{\n  &quot;data&quot;: {\n    &quot;repository&quot;: {\n      &quot;defaultBranchRef&quot;: {\n        &quot;target&quot;: {\n          &quot;file&quot;: {\n            &quot;type&quot;: &quot;tree&quot;,\n            &quot;object&quot;: {\n              &quot;entries&quot;: [\n                {\n                  &quot;name&quot;: &quot;QraphQL.md&quot;,\n                  &quot;object&quot;: {\n                    &quot;text&quot;: &quot;# Exploring GraphQL\\n&quot;\n                  }\n                },\n                {\n                  &quot;name&quot;: &quot;README.md&quot;,\n                  &quot;object&quot;: {\n                    &quot;text&quot;: &quot;# Articles&quot;\n                  }\n                }\n              ]\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>So, if to obtain the entries, we would access them by:</p>\n<pre><code class=\"language-js\">let result = request.data.repository.defaultBranchRef.target.file.type.object.entries\n</code></pre>\n</li>\n</ol>\n<h4 id=\"using-axios\">Using Axios</h4>\n<ol>\n<li><p>Install the <a href=\"https://github.com/axios/axios\">axios npm package</a></p>\n<pre><code class=\"language-bash\">npm install axios\n</code></pre>\n</li>\n<li><p>Import exios into your node project:</p>\n<pre><code class=\"language-js\">import axios from &#39;axios&#39;\n</code></pre>\n</li>\n<li><p>initialize an authentication object and the query string that will be attatched to your request</p>\n<pre><code class=\"language-js\">// The Authorization in the header of the request\nconst oauth = { Authorization: &#39;bearer &#39; + token }\n\n// The Query String\nconst query = `\n        {\n          repository(owner: &quot;lbugasu&quot;, name: &quot;articles&quot;) {\n            defaultBranchRef {\n              target {\n                ... on Commit {\n                  file(path: &quot;/&quot;) {\n                    type\n                    object {\n                      ... on Tree {\n                        entries {\n                          name\n                          object {\n                            ... on Blob {\n                              text\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      `\n</code></pre>\n</li>\n<li><p>Make the request, adding in the query and the header</p>\n<pre><code class=\"language-js\">let request = axios.post(githubUrl, { query: query }, { headers: oauth })\n</code></pre>\n</li>\n<li><p>Parse your output as above:</p>\n<pre><code class=\"language-js\">let result = request.data.repository.defaultBranchRef.target.file.type.object.entries\n</code></pre>\n</li>\n</ol>\n<h2 id=\"referenced-articles\">Referenced articles</h2>\n<ul>\n<li><a href=\"https://gist.github.com/MichaelCurrin/6777b91e6374cdb5662b64b8249070ea\">Graph QL query</a> for getting files.</li>\n<li><a href=\"https://support.insomnia.rest/article/61-graphql\">GraphQL Queries using Insomnia</a></li>\n<li>How to create a personal access token from your github account: <a href=\"https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token\">Creating a personal access token</a></li>\n<li><a href=\"https://medium.com/risan/set-authorization-header-with-apollo-client-e934e6517ccf\">Set Authorization Header with Apollo Client</a></li>\n<li><a href=\"https://stackoverflow.com/questions/58576940/how-to-handle-authorization-header-with-apollo-graphql\">How to handle authorization header with apollo graphql? - Stack Overflow</a></li>\n<li><a href=\"https://dev.to/thomasaudo/get-started-with-github-grapql-api--1g8b\">Get started with GitHub GraphQL API üë®‚Äçüî¨</a> on Dev</li>\n</ul>\n]]></content:encoded>\n            <author>lbugasu@gmail.com (Laurence B. Ininda)</author>\n            <enclosure url=\"https://www.laudebugs.me/post-images/using-your-github-repository-as-a-database.webp\" length=\"0\" type=\"image/webp\"/>\n        </item>\n        <item>\n            <title><![CDATA[How To: Build an Express GraphQL API in TypeScript]]></title>\n            <link>https://www.laudebugs.me/dev/build-graphql-api-in-typescript</link>\n            <guid>https://www.laudebugs.me/dev/build-graphql-api-in-typescript</guid>\n            <pubDate>Tue, 23 Feb 2021 00:00:00 GMT</pubDate>\n            <description><![CDATA[Learn how to build a Node.js GraphQL API with Express and TypeScript]]></description>\n            <content:encoded><![CDATA[<blockquote>\n<p>So you wanna write a node GraphQL backend in TypeScript? Well, Let&#39;s put all the pieces together and begin.</p>\n</blockquote>\n<h2 id=\"initilizing-the-project\">Initilizing the project</h2>\n<p>We&#39;ll be working in a terminal - be it the standalone teminal - or the integrated terminal in your text editor.</p>\n<ol>\n<li><p>Initialize a repository in an empty folder, say, we call ours <code>express-gql-api</code>.:</p>\n<pre><code class=\"language-bash\">mkdir express-gql-api\n\n# enter the project folder\ncd express-gql-api\n</code></pre>\n</li>\n<li><p>Initialize the folder as a node and git project:</p>\n<pre><code class=\"language-bash\">npm init -y\n\ngit init\n</code></pre>\n</li>\n<li><p>Initialize a Readme\nHaving a Readme is essential for any project - this is the document people will see when they come across your repository in Github.</p>\n<br />\nWe'll start off with a simple description but feel free to add more information about your project as you go. ```bash echo '# Express GraphQLAPI\nin TypeScript' > Readme.md ```</li>\n<li><p>Initalize the source directory\nThis is where we will place our <code>.ts</code> files</p>\n<pre><code class=\"language-bash\">mkdir src\n</code></pre>\n</li>\n</ol>\n<h2 id=\"typescript-and-project-setup\">TypeScript and Project SetUp</h2>\n<p>TypeScript is usually compiled to JavaScript and which is the code that is actually run.\nAssuming you already have the <a href=\"https://www.typescriptlang.org/id/download\">TypeScript</a> installed, we will write the configuration file that tells the TypeScript compiler how to compile out files into JavaScript:</p>\n<ol>\n<li><p>Initialize a <code>tsconfig.json</code> file in your root directory from the terminal</p>\n<pre><code class=\"language-bash\">tsc --init\n</code></pre>\n</li>\n<li><p>. Working in the text editor, we will set the following compiler options:</p>\n<ol>\n<li><p><code>&quot;rootDir&quot;</code> - this is the directory where the TypeScript compiler will search for <code>.ts</code> files to compile into JavaScript. In our case, the root directory is the <code>src</code> folder:</p>\n<pre><code class=\"language-json\">{\n  &quot;compilerOptions&quot;: {\n    //...\n    &quot;rootDir&quot;: &quot;./src&quot;\n    //...\n  }\n}\n</code></pre>\n</li>\n<li><p><code>&quot;outDir&quot;</code> - this is the directory where the compiled JavaScript will be placed:\nIn our case, we will call our output directory <code>&quot;dist&quot;</code></p>\n<pre><code class=\"language-json\">{\n  &quot;compilerOptions&quot;: {\n    //...\n    &quot;rootDir&quot;: &quot;./src&quot;,\n    &quot;ourDir&quot;: &quot;./dist&quot;\n    //...\n  }\n}\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>Finally, we will edit the package.json file so that we have a smooth time running the project. Add the following line under script in <code>package.json</code>:</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;:{\n  //...\n   &quot;start&quot; : &quot;nodemon dist/index.js&quot;,\n   //...\n}\n</code></pre>\n</li>\n</ol>\n<p>This is the basic setup that we need before we get started</p>\n<h2 id=\"setup\">SetUp</h2>\n<p>We will be working with a few packages that we need to install:</p>\n<ol>\n<li><a href=\"https://www.npmjs.com/package/express\"><code>express</code></a> - since we are buiding an express server</li>\n<li><a href=\"https://www.npmjs.com/package/express-graphql\"><code>express-graphql</code></a> - this is the express middleware that will allow us to build our graphQL endpoint</li>\n<li><a href=\"https://github.com/ardatan/graphql-tools#readme\"><code>graphql-tools</code></a> - A package that helps build the GraphQL Schema</li>\n<li><a href=\"https://www.npmjs.com/package/mongoose\"><code>mongoose</code></a> - The library that will allow us to connect to a MongoDB database</li>\n</ol>\n<p>Before we jump right into installing the packages, let&#39;s create a <code>.gitignore</code> file at the root folder and add <code>node_modules</code> so that git doesn&#39;t track npm packages:</p>\n<pre><code class=\"language-bash\">echo node_modules &gt; .gitignore\n</code></pre>\n<p>To install all the tools, we can do so in one command:</p>\n<pre><code class=\"language-bash\">npm i -s express express-graphql graphql-tools mongoose nodemon\n</code></pre>\n<p>Before we start writing some code, we need to have our TypeScript compiler running so that we can generate the JavaScript files as we go. So, in a separate window, run the typescript compiler with a watch flag:</p>\n<pre><code class=\"language-bash\">tsc -w\n</code></pre>\n<p>And now we are ready to build our api</p>\n<h2 id=\"the-api-ü•ë\">The API ü•ë</h2>\n<p>Let&#39;s add some files to our file structure first:</p>\n<pre><code>üì¶express-gql-api\n‚î£ üìÇsrc\n‚î£ üìú.gitignore\n‚î£ üìúReadme.md\n‚î£ üìúpackage.json\n‚îó üìútsconfig.json\n</code></pre>\n<p>However, let&#39;s add some files in the <code>src</code> folder first\nCreate an empty directory in the <code>src</code> folder called <code>data</code> - this is where we willl be placing out database connectors, types, schemas and resolver files.\nCreate the following files to match the following structure:</p>\n<pre><code>üì¶express-gql-api\n‚î£ üìÇsrc\n‚îÉ ‚î£ üìÇdata\n‚îÉ ‚îÉ ‚î£ üìúdb.ts\n‚îÉ ‚îÉ ‚î£ üìúresolvers.ts\n‚îÉ ‚îÉ ‚î£ üìúschema.ts\n‚îÉ ‚îÉ ‚îó üìútypes.ts\n‚îÉ ‚îó üìúindex.ts\n‚î£ üìúReadme.md\n‚î£ üìúpackage.json\n‚îó üìútsconfig.json\n</code></pre>\n<h3 id=\"schema-definition\">Schema Definition</h3>\n<p>GraphQL requires a schema to be defined. A schema what graphQL uses to know what type of data to expect.</p>\n<br />\nWe will define the schema in the `schema.ts` file in the following way: We will use our graphQL endpoint to create and query a user. So we need\nto define:\n\n<ul>\n<li><p>a <code>user</code> type</p>\n</li>\n<li><p>a <code>UserInput</code> input - that has the same structure as the <code>User</code> type</p>\n</li>\n<li><p>a <code>Query</code> type - where we will define all the queries</p>\n</li>\n<li><p>a <code>Mutation</code> type - where we will define the mutations</p>\n<pre><code class=\"language-ts\">import { resolvers } from &#39;./resolvers&#39;\nimport { makeExecutableSchema } from &#39;graphql-tools&#39;\n\nconst typeDefs = `\n    type User {\n      name: String\n      username: String\n    }\n    input UserInput {\n      name: String\n      username: String\n    }\n    type Query {\n      getUser(username: String): User\n    }\n    type Mutation{\n      createUser(user: UserInput): User\n    }\n  `\n// Build the schema and export\nconst schema = makeExecutableSchema({ typeDefs, resolvers })\nexport { schema }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"definine-the-type---typets\">Definine the type - <code>type.ts</code></h3>\n<pre><code class=\"language-ts\">export class UserType {\n  constructor(public name: String, public username: String) {}\n}\n</code></pre>\n<h3 id=\"connecting-the-database\">Connecting the Database</h3>\n<h4 id=\"setting-up-the-mongodb-instance-üóÑÔ∏è\">Setting up the MongoDB instance üóÑÔ∏è</h4>\n<p>Before we move into this step, we will need to first set up our database. One can do so by following this process:</p>\n<ol>\n<li>create a free MongoDB account <a href=\"https://account.mongodb.com/account/login\">here</a></li>\n<li>Create a <strong>free</strong> cluster.</li>\n<li>Once the cluster has been created, click <code>connect</code> to your cluster. Further instructions can be found <a href=\"https://docs.atlas.mongodb.com/connect-to-cluster/\">here</a></li>\n<li>You will need to add a connection IP address - typically your own IP for development locally</li>\n<li>create a database user with a username and password - You will need this to login to your database later</li>\n<li>Proceed to choosing a connection method - in our case we will use the <code>connect your application</code> option</li>\n<li>This will lead us to a page to select our driver and version - which in our case should be <code>Node.js</code> Version <code>3.6 or later</code>.</li>\n<li>Copy your connection string somewhere safe that you can edit. You will notice that the username is included in the connection string but you will need to replace the <code>&lt;password&gt;</code> with your password and also pick a name for our database\n{&#39; &#39;}<br />\nAssuming our username was `amani` with password `AEDPfTeq61WH04NL`, and we want our database to be called `bliss`, our connection string would\nlook like:</li>\n</ol>\n<pre><code class=\"language-txt\">mongodb+srv://amani:AEDPfTeq61WH04NL@cluster0.9ntf0.mongodb.net/bliss?retryWrites=true&amp;w=majority\n</code></pre>\n<ol start=\"9\">\n<li>Save this connection string somewhere where you can reference it later as we will need it when running our program.</li>\n</ol>\n<h4 id=\"connecting-to-the-database-programmatically---dbts\">Connecting to the Database programmatically - <code>db.ts</code></h4>\n<p>In the <code>db.js</code> file, we will import <code>mongoose</code> and then define a new schema for the database - in our case, the only schema we will need is the user schema.</p>\n<br />\nWe will then create a new mongoose model that will be exported for use to query the database. Notice that we have set the `connectionString`\nvariable to an environment variable - this is safer than pasting the connection string right into your code because it makes your database vulnerable.\nIn our case, will set the connection string to an environment varible when we are ready to run the application.\n\n<pre><code class=\"language-ts\">import mongoose from &#39;mongoose&#39;\nconst Schema = mongoose.Schema\n\n// @ts-ignore\nconst connectionString: String = process.env.MONGO_DB\n// @ts-ignore\nmongoose.connect(connectionString, {\n  useNewUrlParser: true,\n  useUnifiedTopology: true,\n  useFindAndModify: false,\n  useCreateIndex: true\n})\n\nconst UserSchema = new Schema({\n  name: String,\n  username: String\n})\n\nconst User = mongoose.model(&#39;User&#39;, UserSchema)\n\nexport { User }\n</code></pre>\n<h3 id=\"declaring-the-resolvers---resolversts\">Declaring the resolvers - <code>resolvers.ts</code></h3>\n<p>The resolvers are the functions that are run whenever the endpoint is run - so you need to define a function for each query and mutation as we will do below:</p>\n<pre><code class=\"language-ts\">import { UserType } from &#39;./types&#39;\n\n// import the User from the database\nimport { User } from &#39;./db&#39;\n\nexport const resolvers = {\n  Query: {\n    //@ts-ignore\n    getUser: (root, { username }) =&gt; {\n      return User.findOne({ username: username })\n        .then((user: UserType) =&gt; {\n          return user\n        })\n        .catch((error: any) =&gt; {\n          console.log(error.message)\n        })\n    }\n  },\n  Mutation: {\n    // @ts-ignore\n    createUser: async (root, { user }) =&gt; {\n      const newUser = new User({ name: user.name, username: user.username })\n      await newUser.save()\n      return newUser\n    }\n  }\n}\n</code></pre>\n<h2 id=\"piece-the-pie-together-ü•ß---indexts\">Piece the pie together ü•ß - <code>index.ts</code></h2>\n<p>Our <code>index.ts</code> file is where all the majic happens. We will begin by importing the necessary packages and instantiating a new express app. Then we will initialize the connection to the database and attach the <code>grapqlHTTP</code> middleware function with our schema and <code>graphiql</code> - which we can use to explore the api:</p>\n<pre><code class=\"language-ts\">import express from &#39;express&#39;\nimport { graphqlHTTP } from &#39;express-graphql&#39;\nimport { schema } from &#39;./data/schema&#39;\n\n// Initialize app\nconst app = express()\nrequire(&#39;./data/db&#39;)\n\n// the graphQL endpoint at /graphql.\napp.use(&#39;/graphql&#39;, graphqlHTTP({ schema: schema, graphiql: true }))\n\napp.get(&#39;*&#39;, (req, res) =&gt; {\n  res.json({ message: &#39;Welcome to the api&#39; })\n})\n\nconst PORT = 7000\napp.listen(PORT, () =&gt; {\n  console.log(`api is running on port ${PORT}`)\n})\n</code></pre>\n<h2 id=\"running-the-server\">Running the server</h2>\n<p>Before we run the server, we will need to add our mongoDB connection string to the environment variables:</p>\n<pre><code class=\"language-bash\">  export MONGO_DB=&#39;mongodb+srv://amani:AEDPfTeq61WH04NL@cluster0.9ntf0.mongodb.net/bliss?retryWrites=true&amp;w=majority&#39;\n</code></pre>\n<p>Now, we are ready to run the server üöÄ</p>\n<pre><code class=\"language-bash\">  npm run start\n</code></pre>\n<p>And we can run the server and explore our api.\nHere&#39;s an example of a mutation that you can make with the api:</p>\n<h3 id=\"mutation\">Mutation</h3>\n<p>We can add a user by making a mutation on the api:</p>\n<pre><code class=\"language-txt\">  mutation createUser ($input:UserInput){\n    createUser(user:$input) {\n      name\n      username\n    }\n  }\n</code></pre>\n<p>We can then pass in the user input using the query variables:</p>\n<pre><code class=\"language-txt\">  {\n    &quot;input&quot;: {\n      &quot;name&quot;: &quot;Laurence&quot;,\n      &quot;username&quot;: &quot;laudebugs&quot;\n    }\n  }\n</code></pre>\n<p>Here&#39;s how the mutation looks like:</p>\n<p>&lt;img src={&#39;<a href=\"https://raw.githubusercontent.com/lbugasu/articles/main/resources/graphqlmutation.png&#39;%7D\">https://raw.githubusercontent.com/lbugasu/articles/main/resources/graphqlmutation.png&#39;}</a> width={&#39;100%&#39;} /&gt;</p>\n<h3 id=\"query\">Query</h3>\n<p>If we were to then ask the api for a certain user, we can make the query by:</p>\n<pre><code class=\"language-txt\">  query {\n    getUser (username:&quot;laudebugs&quot;){\n      name\n    }\n  }\n</code></pre>\n<p>You can check out the <a href=\"https://github.com/lbugasu/express-gql-api\">repo here</a></p>\n<h3 id=\"common-issues-that-you-may-run-into\">Common Issues that you may run into:</h3>\n<ol>\n<li><strong>IP isn&#39;t whitelisted</strong>: If you&#39;re running into this issue, it may be the case that your ip address has changed and you need to add your current IP to be able to connect.</li>\n<li><strong>Could not find a declaration file for &#39;express&#39;</strong>\nInstall the declaratio file for <code>express</code>:</li>\n</ol>\n<pre><code class=\"language-bash\">    npm i --save-dev express\n</code></pre>\n<h2 id=\"further-reading\">Further Reading</h2>\n<ul>\n<li><a href=\"https://medium.com/atheros/graphql-quick-tip-how-to-pass-variables-into-a-mutation-in-graphiql-23ecff4add57\">GraphQL quick tip: How to pass variables in GraphiQL</a></li>\n</ul>\n]]></content:encoded>\n            <author>lbugasu@gmail.com (Laurence B. Ininda)</author>\n            <enclosure url=\"https://www.laudebugs.me/post-images/build-graphql-api-in-typescript.jpg\" length=\"0\" type=\"image/jpg\"/>\n        </item>\n        <item>\n            <title><![CDATA[Kenya Web Project]]></title>\n            <link>https://www.laudebugs.me/dev/kenya-web-project</link>\n            <guid>https://www.laudebugs.me/dev/kenya-web-project</guid>\n            <pubDate>Fri, 05 Jun 2020 00:00:00 GMT</pubDate>\n            <description><![CDATA[Examining performance and data download sizes of Kenya's top 500 websites. Expecially in emerging markets, website developers need to build small and efficient web applications.]]></description>\n            <content:encoded><![CDATA[<h2 id=\"foreground\">Foreground</h2>\n<p>The internet is a vast ‚Äúland‚Äù with plenty of room to create, share and find content. Internet usage in Kenya is increasing by the year. COVID-19 brought to the forefront, the importance of having an online presence. Companies like Amazon, that were internet-first, widened their market share of internet sales and became more relevant. Those companies that didn‚Äôt have an online presence realized that they needed to adapt quickly to the times. Even people realized that they needed to build an online presence to showcase their work or seek jobs.</p>\n<p>In developing countries like Kenya, with companies shifting online, there is a growing need to track these trends. However, data is still expensive for the average Kenyan even though data consumption in the country has been increasing by the year. Therefor, in as much as companies are moving online, they need to take into consideration this very fact that accessing websites should not require a large amount of data ‚Äì say more than 2MB (to be revised later). And web developers need to be creative in ways that they can reduce data consumption on subsequent website visits to the sites they build. For instance, through caching or giving users a low-data version of their site once they land on the page before loading any subsequent content.</p>\n<h2 id=\"conceptualization\">Conceptualization</h2>\n<p>Through¬†this¬†project,¬†I¬†would¬†like¬†to¬†accomplish¬†two¬†things:</p>\n<ul>\n<li>Create¬†a¬†directory¬†of¬†Kenyan¬†websites - websites¬†with¬†extensions¬†‚Äú.co.ke‚Äù¬†or¬†‚Äú.ke‚Äù or that include¬†‚Äúkenya‚Äù¬†within the domain¬†name.</li>\n<li>Of¬†the¬†collected¬†sites,¬†note¬†how¬†much¬†data¬†is¬†downloaded¬†on¬†the¬†landing¬†page of¬†the site¬†and¬†organize¬†this¬†data¬†into¬†a¬†repository.</li>\n</ul>\n<h2 id=\"data-collection-and-preparation\">Data Collection and Preparation</h2>\n<p>How many websites can I find by randomly searching common words and the big companies in Kenya?</p>\n<p>After considering this, I searched the internet to try to find a difinitive list of websites in Kenya. To find this list, I would have to contact organizations like The Kenya Network Information Centre (KENIC) to obtain this information. And although this seemed like the route to go, I also found a list of the top 500 websites in Kenya provided by Alexa and figured that this list would be more useful to use as a baseline of websites in Kenya. And as the list showed, there&#39;s a large number of domains that do not end with .co.ke or .ke that Kenyans use. After signing up for the free trial, I parsed the data to this json file using a simple java script.</p>\n<p>Considering all the information that lighthouse provided, two metrics seemed important: the performance of the site as well as the amount of data downloaded when a user accesses the website., i.e. Total size.\nTwo metrics: Performance and total size downloaded on page load\nThe size will vary from device to device since mobile devices might have cached the websites before or CDN&#39;s might be used to deliver a faster and smaller payload.</p>\n<h3 id=\"why-lighthouse\">Why lighthouse?</h3>\n<p>Google provides Lighthouse as a developer tool to generate a report on a website. The tool is also available as a commandline interface tool. However, I wanted to use the tool as part of a node.js project. Therefore, I stumbled on this project by Sahava on github from which I borrowed heavily and modified to my own use.\nGenerating¬†the¬†Reports</p>\n<p>Since my computer crawled at even the thought of running lighthouse on 500 websites, I decided to run the runLightHouse.js script on AWS.\nHere are the steps for creating an AWS instance:\nAfter Creating an Amazon AWS account,\nCreate an EC2 instance. You can proceed with launching an instance that contains the free tier.</p>\n<pre><code>Launch instance &gt; Ubuntu 20.04 (with Free tier eligible) &gt; General Purpose Instance Type &gt; Choose an Existing Key-pair for ssh into your instance or download a new instance &gt;Launch instance\n</code></pre>\n<p>I however created an instance type with a GPU (just for fun) and to perform lighthouse processes fast. (this cost a couple of cents/hr)\nSSH into your instance:</p>\n<pre><code class=\"language-bash\"># move your .pem file into the come folder\n# Assuming you downloaded the .pem file to the downloads folder:\n# cd into the root directory\ncd\n# check whether a .ssh folder exists\nls -al\n# if it doesn&#39;t, create the folder\nmkdir .ssh\n#move the .pem file into the .ssh folder. Here assume I call my .pem file myKeyPair\nmv [path where the .pem file exists]/myKeyPair.pem myKeyPair.pem\n# change the permissions of the .pem file\nchmod 400 .ssh/myKeyPair.pem\n</code></pre>\n<p>Copy your Public DNS (IPv4) from your AWS instance - this is usually located at your instances page when you click on your instance</p>\n<p>SSH into your instance</p>\n<pre><code class=\"language-bash\"># replace [my public ip with the actual ip]\nssh -i ~/.ssh/myKeyPair.pem ubuntu@[Public DNS (IPv4)]\n# you may be asked whether to type yes or no to proceed. Type yes to proceed\n\n# Prepare the server to run your script\ninstall git\nsudo apt install git -y\n# Install latest version of npm\ncurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash\nsudo apt-get install -y nodejs\n# Install Chrome. I referenced this article\n\n# Download Google chrome\nwget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\n# install google chrome\nsudo apt install ./google-chrome-stable_current_amd64.deb\n</code></pre>\n<h3 id=\"running-the-script\">Running the script</h3>\n<pre><code class=\"language-bash\"># Clone the repo\ngit clone https://github.com/lbugasu/kenya-web-project.git\n\n# enter project folder\ncd kenya-web-project\n\n# Install packages\nnpm i\n\n# Run the script\nnode generateReports.js\n# Exit the AWS instance\n</code></pre>\n<h2 id=\"update\">Update</h2>\n<p>I tried running the script on an amazon linux server but there was always an error generated, so I switched to using an ubuntu 20.04 instance.\nBelow are the instructions fro setting up and to ssh into an Amazon linux ec2 instance:\nAfter Creating an Amazon AWS account,\nCreate an EC2 instance. You can proceed with launching an instance that contains the free tier.</p>\n<pre><code class=\"language-text\">Launch instance &gt; Amazon Linux (with Free tier eligible) &gt; General Purpose Instance Type &gt; Choose an Existing Key-pair for ssh into your instance or download a new instance &gt;Launch instance\n</code></pre>\n<p>I however created an instance type with a GPU (just for fun) and to perform lighthouse processes fast. (this cost a couple of cents/hr)\nSSH into your instance:</p>\n<pre><code class=\"language-bash\"># move your .pem file into the come folder\n# Assuming you downloaded the .pem file to the downloads folder:\n# cd into the root directory\ncd [root directory]\n\n# check whether a .ssh folder exists\nls -al\n\n# if it doesn&#39;t, create the folder\nmkdir .ssh\n#move the .pem file into the .ssh folder. Here assume I call my .pem file myKeyPair\nmv [path where the .pem file exists]/myKeyPair.pem myKeyPair.pem\n\nChange the permissions of the .pem file\n```bash\nchmod 400 .ssh/myKeyPair.pem\n</code></pre>\n<p>Copy your Public DNS (IPv4) from your AWS instance - this is usually located at your instances page when you click on your instance</p>\n<pre><code>SSH into your instance\n```bash\n# replace [my public ip with the actual ip]\nssh -i ~/.ssh/myKeyPair.pem ec2-user@[Public DNS (IPv4)]\n</code></pre>\n<p>You may be asked whether to type yes or no to proceed. Type yes to proceed</p>\n<pre><code class=\"language-bash\"># Prepare the server to run your script\n# install git\nsudo yum install git -y\n</code></pre>\n<p>install npm using Amazon&#39;s instructions</p>\n<pre><code class=\"language-bash\"># Install latest version of npm\nnpm install -g npm@latest\n# Install Chrome. I referenced this article\ncurl https://intoli.com/install-google-chrome.sh | bash\n</code></pre>\n<h4 id=\"running-the-script-1\">Running the script</h4>\n<pre><code class=\"language-bash\">#Clone the repo\ngit clone https://github.com/lbugasu/kenya-web-project.git\n\n# enter project folder\n```bash\ncd kenya-web-project\n# Install packages\nnpm i\n# Exit the AWS instance\nexit\n</code></pre>\n<h2 id=\"analysis\">Analysis</h2>\n<p>Having obtained two additional metrics of each website, i.e. the performance and size of page downloaded, then we can plot several graphs to gauge how one metric affects the other.</p>\n<p>In order to answer questions that the data presented, there still remained missing pieces of information that would enable me to analyze the data accurately. With metrics such as performance, size of webpage downloaded and average time spent on a website, we could take a look at the general trend of the top websites in Kenya as shown below.</p>\n<p>&lt;img\n  alt=&quot;Size of the web page downloaded&quot;\n  src={&#39;<a href=\"https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/Size%20of%20the%20web%20page%20downloaded.png&#39;%7D\">https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/Size%20of%20the%20web%20page%20downloaded.png&#39;}</a>\n  width={&#39;100%&#39;}\n/&gt;</p>\n<p>The optimal size of a web page is 0 - 1 MB downloaded once a use logs onto a site. This is of course, not taking into account cached resources that might reduce the size of the page downloaded.</p>\n<p>&lt;img\n  alt=&quot;TimeSpentOnWebsite&quot;\n  src={&#39;<a href=\"https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/TimeSpentOnWebsite.png&#39;%7D\">https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/TimeSpentOnWebsite.png&#39;}</a>\n  width={&#39;100%&#39;}\n/&gt;</p>\n<p>The modal time spent on a website by Kenyans is 3 minutes with the average coming to 7.2682 minutes.</p>\n<h2 id=\"postscript\">Postscript</h2>\n<p>In analyzing the dataset, there&#39;s a temptation to draw immediate conclusions from the various datapoints such as comparing the time spent and how this changes based on the size of the web page downloaded when a user accesses the website. However, this analysis doesn&#39;t take into account the fact that different websites serve different functions. For instance, a person logging into the Kenya Revenue Authority website would perhaps use the site for a specific predetermined use case while a person using YouTube might not have a goal in mind while using the site. And therefore one would need to make assumptions to immediately draw conclusions from the data. On modelling the graph, the size of the page downloaded doesn&#39;t relate to how much time is spent on the site.\nFurther information is needed to ask deeper questions from the dataset. One such piece is the genre of the website which would be able to draw distinctions between the different websites and make comparisons within websites of a certain type.\nAs of now, the dataset is freely available to use and for more research to be done. Especially at a time when the internet is crucial to keep systems moving during Covid-19, we need to examine more closely how Kenyans use the internet.\nHiccups along the way\nIn generating the lighthouse reports for the site, I decided to splice the list of websites into groups of 30 websites at a time - because even AWS servers weren&#39;t running all the reports smoothly. At other times, I ran 50 reports at a time. However, while doing this, I realised I skipped over close to 70 websites spread over my input set of 500. And so, I wrote a small python script to find the missing sites.\nI had to manually run the website Bet365.com using the lighthouse cli because the node script kept timing out</p>\n<h3 id=\"after-installing-lighthouse\">After installing lighthouse</h3>\n<p><code>npm install -g lighthouse</code></p>\n<pre><code class=\"language-bash\">lighthouse https://www.bet365.com/ --quiet --output json --output-path ./www_Bet365_com.json\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/sahava/multisite-lighthouse\">Multisite Lighthouse</a></li>\n<li><a href=\"https://www.alexa.com/topsites/countries/KE\">Top Sites in Kenya</a></li>\n<li>Google Chrome Lighthouse <a href=\"https://github.com/GoogleChrome/lighthouse\">Github Repository</a></li>\n</ul>\n<p>-&gt; Checkout the <a href=\"https://github.com/lbugasu/kenya-web-project\">Github Repository</a></p>\n]]></content:encoded>\n            <author>lbugasu@gmail.com (Laurence B. Ininda)</author>\n            <enclosure url=\"https://www.laudebugs.me/post-images/kenya-web-project.jpg\" length=\"0\" type=\"image/jpg\"/>\n        </item>\n    </channel>\n</rss>",
    "json": "\"{\\n    \\\"version\\\": \\\"https://jsonfeed.org/version/1\\\",\\n    \\\"title\\\": \\\"Lau de Bugs' Blog\\\",\\n    \\\"home_page_url\\\": \\\"https://www.laudebugs.me/api/rss\\\",\\n    \\\"feed_url\\\": \\\"https://www.laudebugs.me/api/rss/json\\\",\\n    \\\"description\\\": \\\"Life and Software Development Blog\\\",\\n    \\\"icon\\\": \\\"https://www.laudebugs.me/images/logos/logo_light.png\\\",\\n    \\\"author\\\": {\\n        \\\"name\\\": \\\"Laurence B. Ininda\\\",\\n        \\\"url\\\": \\\"https://www.laudebugs.me/\\\"\\n    },\\n    \\\"items\\\": [\\n        {\\n            \\\"content_html\\\": \\\"<h1 id=\\\\\\\"how-to-use-your-repo-as-a-database-with-the-github-graphql-api\\\\\\\">How To: Use your Repo as a Database with the Github GraphQL API</h1>\\\\n<blockquote>\\\\n<p>You can sort of use your Github repository as a database for your blog posts by leveraging the Github <a href=\\\\\\\"https://docs.github.com/en/graphql\\\\\\\">Graph QL API</a> üò±.</p>\\\\n</blockquote>\\\\n<h2 id=\\\\\\\"motivation\\\\\\\">Motivation</h2>\\\\n<p>The Github GraphQL API provides a lot more capabilities than I can cover in one <em>snack</em>.</p>\\\\n<p>However, in searching for a way to share the small lessons that I pick up week in week out, I knew that publishing through <a href=\\\\\\\"https://www.contentful.com/\\\\\\\">Contentful</a>, which it the CMS, I use for the main content in my blog site, was a little too much to share easily and quicly.\\\\nPosting on Github and sharing that as <a href=\\\\\\\"https://gist.github.com/lbugasu\\\\\\\">gists</a> seemed like I would be writing too much for a gist that is supposed to be a short code snippet - which was the original title of this section. Although <a href=\\\\\\\"https://gist.github.com/MichaelCurrin/6777b91e6374cdb5662b64b8249070ea\\\\\\\">MichaelCurrin</a> proves me otherwise! His article is what got me goint in the first place!</p>\\\\n<h2 id=\\\\\\\"querying-the-graphql-api-for-posts\\\\\\\">Querying the GraphQL API for posts.</h2>\\\\n<p>In order to use the Github GraphQL API, you can either use the <a href=\\\\\\\"https://docs.github.com/en/graphql/overview/explorer\\\\\\\">API explorer</a> by logging in through your github account, use an api testing tool like <a href=\\\\\\\"https://support.insomnia.rest/article/61-graphql\\\\\\\">Insomnia</a>, or you can use it programmatically.</p>\\\\n<p>Since I was using the Apollo Graph QL library to query my backend - that helps me manage comments and likes, I began to do a little research on how to query the Github GraphQL API. I will link the articles below.\\\\nThis <a href=\\\\\\\"https://stackoverflow.com/questions/58576940/how-to-handle-authorization-header-with-apollo-graphql\\\\\\\">stack overflow</a> answered how to add an authorization header to an Apollo Client Query.</p>\\\\n<h2 id=\\\\\\\"the-query\\\\\\\">The Query</h2>\\\\n<p>We will be using writing our query in a node.js environment using both <a href=\\\\\\\"https://github.com/apollographql/apollo-client\\\\\\\">Apollo Client</a> and <a href=\\\\\\\"https://github.com/axios/axios\\\\\\\">Axios</a></p>\\\\n<h3 id=\\\\\\\"1-obtain-your-github-public-access-token\\\\\\\">1. Obtain your github public access token</h3>\\\\n<p>The only permission you need for this task is <code>public_repo</code> under <code>repo</code>:</p>\\\\n<ul>\\\\n<li><input disabled=\\\\\\\"\\\\\\\" type=\\\\\\\"checkbox\\\\\\\"> repo<ul>\\\\n<li><input checked=\\\\\\\"\\\\\\\" disabled=\\\\\\\"\\\\\\\" type=\\\\\\\"checkbox\\\\\\\"> public_repo</li>\\\\n</ul>\\\\n</li>\\\\n</ul>\\\\n<p>Give your token a name and will look something like this:</p>\\\\n<pre><code class=\\\\\\\"language-txt\\\\\\\">89fdd35bcd40787b519e97462cec0f9975a66a58\\\\n</code></pre>\\\\n<p>Note the token above is revoked and you&#39;ll need to generate yours. Once you&#39;re done, we&#39;re ready for the next step!</p>\\\\n<h3 id=\\\\\\\"2-querying-the-repo\\\\\\\">2. Querying the repo</h3>\\\\n<p>In my case, I will be looking for files in my repository called <code>articles</code>. If you&#39;d like to use your own repository, simply make note of your repository name.</p>\\\\n<h3 id=\\\\\\\"using-the-apollo-client\\\\\\\">Using the Apollo Client</h3>\\\\n<ol>\\\\n<li><p>Install the Apollo client</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">npm install @apollo/client graphql\\\\n</code></pre>\\\\n</li>\\\\n<li><p>Working in your js file, import the Apollo client and a few methods that we will make use of:</p>\\\\n<pre><code class=\\\\\\\"language-js\\\\\\\">import { ApolloClient, InMemoryCache, gql, ApolloLink, HttpLink } from &#39;@apollo/client&#39;\\\\n</code></pre>\\\\n</li>\\\\n<li><p>Initialize a new apollo client with the github graphQL endpoint and your token</p>\\\\n<pre><code class=\\\\\\\"language-js\\\\\\\">const token = &#39;89fdd35bcd40787b519e97462cec0f9975a66a58&#39;\\\\n\\\\nconst endpoint = &#39;https://api.github.com/graphql&#39;\\\\n\\\\n// Add the toke to the header of your client for all your requests\\\\nconst githubLClient = new ApolloClient({\\\\n  uri: endpoint,\\\\n  headers: {\\\\n    authorization: `Bearer ${token}`\\\\n  },\\\\n  cache: new InMemoryCache({\\\\n    addTypename: false\\\\n  })\\\\n})\\\\n</code></pre>\\\\n</li>\\\\n<li><p>Make the query\\\\nI referenced github user <a href=\\\\\\\"https://gist.github.com/int128/b0e75e3043c8a33808cea0089d988ed3\\\\\\\">int128&#39;s gist</a> for the structure of the graphQl query:</p>\\\\n<pre><code class=\\\\\\\"language-js\\\\\\\">let request = await githubClient.query({\\\\n  query: gql`\\\\n    {\\\\n      repository(owner: &quot;lbugasu&quot;, name: &quot;articles&quot;) {\\\\n        defaultBranchRef {\\\\n          target {\\\\n            ... on Commit {\\\\n              file(path: &quot;/&quot;) {\\\\n                type\\\\n                object {\\\\n                  ... on Tree {\\\\n                    entries {\\\\n                      name\\\\n                      object {\\\\n                        ... on Blob {\\\\n                          text\\\\n                        }\\\\n                      }\\\\n                    }\\\\n                  }\\\\n                }\\\\n              }\\\\n            }\\\\n          }\\\\n        }\\\\n      }\\\\n    }\\\\n  `\\\\n})\\\\n</code></pre>\\\\n</li>\\\\n<li><p>Parse your output to obtain the file&#39;s contents.\\\\nBy making this same query on Github&#39;s GraphQL explorer, the data returned, which is essentially a json object, at the time of writing this, looks like this:</p>\\\\n<pre><code class=\\\\\\\"language-json\\\\\\\">{\\\\n  &quot;data&quot;: {\\\\n    &quot;repository&quot;: {\\\\n      &quot;defaultBranchRef&quot;: {\\\\n        &quot;target&quot;: {\\\\n          &quot;file&quot;: {\\\\n            &quot;type&quot;: &quot;tree&quot;,\\\\n            &quot;object&quot;: {\\\\n              &quot;entries&quot;: [\\\\n                {\\\\n                  &quot;name&quot;: &quot;QraphQL.md&quot;,\\\\n                  &quot;object&quot;: {\\\\n                    &quot;text&quot;: &quot;# Exploring GraphQL\\\\\\\\n&quot;\\\\n                  }\\\\n                },\\\\n                {\\\\n                  &quot;name&quot;: &quot;README.md&quot;,\\\\n                  &quot;object&quot;: {\\\\n                    &quot;text&quot;: &quot;# Articles&quot;\\\\n                  }\\\\n                }\\\\n              ]\\\\n            }\\\\n          }\\\\n        }\\\\n      }\\\\n    }\\\\n  }\\\\n}\\\\n</code></pre>\\\\n<p>So, if to obtain the entries, we would access them by:</p>\\\\n<pre><code class=\\\\\\\"language-js\\\\\\\">let result = request.data.repository.defaultBranchRef.target.file.type.object.entries\\\\n</code></pre>\\\\n</li>\\\\n</ol>\\\\n<h4 id=\\\\\\\"using-axios\\\\\\\">Using Axios</h4>\\\\n<ol>\\\\n<li><p>Install the <a href=\\\\\\\"https://github.com/axios/axios\\\\\\\">axios npm package</a></p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">npm install axios\\\\n</code></pre>\\\\n</li>\\\\n<li><p>Import exios into your node project:</p>\\\\n<pre><code class=\\\\\\\"language-js\\\\\\\">import axios from &#39;axios&#39;\\\\n</code></pre>\\\\n</li>\\\\n<li><p>initialize an authentication object and the query string that will be attatched to your request</p>\\\\n<pre><code class=\\\\\\\"language-js\\\\\\\">// The Authorization in the header of the request\\\\nconst oauth = { Authorization: &#39;bearer &#39; + token }\\\\n\\\\n// The Query String\\\\nconst query = `\\\\n        {\\\\n          repository(owner: &quot;lbugasu&quot;, name: &quot;articles&quot;) {\\\\n            defaultBranchRef {\\\\n              target {\\\\n                ... on Commit {\\\\n                  file(path: &quot;/&quot;) {\\\\n                    type\\\\n                    object {\\\\n                      ... on Tree {\\\\n                        entries {\\\\n                          name\\\\n                          object {\\\\n                            ... on Blob {\\\\n                              text\\\\n                            }\\\\n                          }\\\\n                        }\\\\n                      }\\\\n                    }\\\\n                  }\\\\n                }\\\\n              }\\\\n            }\\\\n          }\\\\n        }\\\\n      `\\\\n</code></pre>\\\\n</li>\\\\n<li><p>Make the request, adding in the query and the header</p>\\\\n<pre><code class=\\\\\\\"language-js\\\\\\\">let request = axios.post(githubUrl, { query: query }, { headers: oauth })\\\\n</code></pre>\\\\n</li>\\\\n<li><p>Parse your output as above:</p>\\\\n<pre><code class=\\\\\\\"language-js\\\\\\\">let result = request.data.repository.defaultBranchRef.target.file.type.object.entries\\\\n</code></pre>\\\\n</li>\\\\n</ol>\\\\n<h2 id=\\\\\\\"referenced-articles\\\\\\\">Referenced articles</h2>\\\\n<ul>\\\\n<li><a href=\\\\\\\"https://gist.github.com/MichaelCurrin/6777b91e6374cdb5662b64b8249070ea\\\\\\\">Graph QL query</a> for getting files.</li>\\\\n<li><a href=\\\\\\\"https://support.insomnia.rest/article/61-graphql\\\\\\\">GraphQL Queries using Insomnia</a></li>\\\\n<li>How to create a personal access token from your github account: <a href=\\\\\\\"https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token\\\\\\\">Creating a personal access token</a></li>\\\\n<li><a href=\\\\\\\"https://medium.com/risan/set-authorization-header-with-apollo-client-e934e6517ccf\\\\\\\">Set Authorization Header with Apollo Client</a></li>\\\\n<li><a href=\\\\\\\"https://stackoverflow.com/questions/58576940/how-to-handle-authorization-header-with-apollo-graphql\\\\\\\">How to handle authorization header with apollo graphql? - Stack Overflow</a></li>\\\\n<li><a href=\\\\\\\"https://dev.to/thomasaudo/get-started-with-github-grapql-api--1g8b\\\\\\\">Get started with GitHub GraphQL API üë®‚Äçüî¨</a> on Dev</li>\\\\n</ul>\\\\n\\\",\\n            \\\"url\\\": \\\"https://www.laudebugs.me/dev/using-your-github-repository-as-a-database\\\",\\n            \\\"title\\\": \\\"Using your GitHub Repository as a Database\\\",\\n            \\\"summary\\\": \\\"You don't have to look far for somewhere to store your content. GitHub is a great place to store your content. Together with the GitHub API, you can use GitHub make this happen.\\\",\\n            \\\"image\\\": \\\"https://www.laudebugs.me/post-images/using-your-github-repository-as-a-database.webp\\\",\\n            \\\"date_modified\\\": \\\"2021-03-01T00:00:00.000Z\\\",\\n            \\\"author\\\": {\\n                \\\"name\\\": \\\"Laurence B. Ininda\\\",\\n                \\\"url\\\": \\\"https://www.laudebugs.me/\\\"\\n            }\\n        },\\n        {\\n            \\\"content_html\\\": \\\"<blockquote>\\\\n<p>So you wanna write a node GraphQL backend in TypeScript? Well, Let&#39;s put all the pieces together and begin.</p>\\\\n</blockquote>\\\\n<h2 id=\\\\\\\"initilizing-the-project\\\\\\\">Initilizing the project</h2>\\\\n<p>We&#39;ll be working in a terminal - be it the standalone teminal - or the integrated terminal in your text editor.</p>\\\\n<ol>\\\\n<li><p>Initialize a repository in an empty folder, say, we call ours <code>express-gql-api</code>.:</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">mkdir express-gql-api\\\\n\\\\n# enter the project folder\\\\ncd express-gql-api\\\\n</code></pre>\\\\n</li>\\\\n<li><p>Initialize the folder as a node and git project:</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">npm init -y\\\\n\\\\ngit init\\\\n</code></pre>\\\\n</li>\\\\n<li><p>Initialize a Readme\\\\nHaving a Readme is essential for any project - this is the document people will see when they come across your repository in Github.</p>\\\\n<br />\\\\nWe'll start off with a simple description but feel free to add more information about your project as you go. ```bash echo '# Express GraphQLAPI\\\\nin TypeScript' > Readme.md ```</li>\\\\n<li><p>Initalize the source directory\\\\nThis is where we will place our <code>.ts</code> files</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">mkdir src\\\\n</code></pre>\\\\n</li>\\\\n</ol>\\\\n<h2 id=\\\\\\\"typescript-and-project-setup\\\\\\\">TypeScript and Project SetUp</h2>\\\\n<p>TypeScript is usually compiled to JavaScript and which is the code that is actually run.\\\\nAssuming you already have the <a href=\\\\\\\"https://www.typescriptlang.org/id/download\\\\\\\">TypeScript</a> installed, we will write the configuration file that tells the TypeScript compiler how to compile out files into JavaScript:</p>\\\\n<ol>\\\\n<li><p>Initialize a <code>tsconfig.json</code> file in your root directory from the terminal</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">tsc --init\\\\n</code></pre>\\\\n</li>\\\\n<li><p>. Working in the text editor, we will set the following compiler options:</p>\\\\n<ol>\\\\n<li><p><code>&quot;rootDir&quot;</code> - this is the directory where the TypeScript compiler will search for <code>.ts</code> files to compile into JavaScript. In our case, the root directory is the <code>src</code> folder:</p>\\\\n<pre><code class=\\\\\\\"language-json\\\\\\\">{\\\\n  &quot;compilerOptions&quot;: {\\\\n    //...\\\\n    &quot;rootDir&quot;: &quot;./src&quot;\\\\n    //...\\\\n  }\\\\n}\\\\n</code></pre>\\\\n</li>\\\\n<li><p><code>&quot;outDir&quot;</code> - this is the directory where the compiled JavaScript will be placed:\\\\nIn our case, we will call our output directory <code>&quot;dist&quot;</code></p>\\\\n<pre><code class=\\\\\\\"language-json\\\\\\\">{\\\\n  &quot;compilerOptions&quot;: {\\\\n    //...\\\\n    &quot;rootDir&quot;: &quot;./src&quot;,\\\\n    &quot;ourDir&quot;: &quot;./dist&quot;\\\\n    //...\\\\n  }\\\\n}\\\\n</code></pre>\\\\n</li>\\\\n</ol>\\\\n</li>\\\\n<li><p>Finally, we will edit the package.json file so that we have a smooth time running the project. Add the following line under script in <code>package.json</code>:</p>\\\\n<pre><code class=\\\\\\\"language-json\\\\\\\">&quot;scripts&quot;:{\\\\n  //...\\\\n   &quot;start&quot; : &quot;nodemon dist/index.js&quot;,\\\\n   //...\\\\n}\\\\n</code></pre>\\\\n</li>\\\\n</ol>\\\\n<p>This is the basic setup that we need before we get started</p>\\\\n<h2 id=\\\\\\\"setup\\\\\\\">SetUp</h2>\\\\n<p>We will be working with a few packages that we need to install:</p>\\\\n<ol>\\\\n<li><a href=\\\\\\\"https://www.npmjs.com/package/express\\\\\\\"><code>express</code></a> - since we are buiding an express server</li>\\\\n<li><a href=\\\\\\\"https://www.npmjs.com/package/express-graphql\\\\\\\"><code>express-graphql</code></a> - this is the express middleware that will allow us to build our graphQL endpoint</li>\\\\n<li><a href=\\\\\\\"https://github.com/ardatan/graphql-tools#readme\\\\\\\"><code>graphql-tools</code></a> - A package that helps build the GraphQL Schema</li>\\\\n<li><a href=\\\\\\\"https://www.npmjs.com/package/mongoose\\\\\\\"><code>mongoose</code></a> - The library that will allow us to connect to a MongoDB database</li>\\\\n</ol>\\\\n<p>Before we jump right into installing the packages, let&#39;s create a <code>.gitignore</code> file at the root folder and add <code>node_modules</code> so that git doesn&#39;t track npm packages:</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">echo node_modules &gt; .gitignore\\\\n</code></pre>\\\\n<p>To install all the tools, we can do so in one command:</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">npm i -s express express-graphql graphql-tools mongoose nodemon\\\\n</code></pre>\\\\n<p>Before we start writing some code, we need to have our TypeScript compiler running so that we can generate the JavaScript files as we go. So, in a separate window, run the typescript compiler with a watch flag:</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">tsc -w\\\\n</code></pre>\\\\n<p>And now we are ready to build our api</p>\\\\n<h2 id=\\\\\\\"the-api-ü•ë\\\\\\\">The API ü•ë</h2>\\\\n<p>Let&#39;s add some files to our file structure first:</p>\\\\n<pre><code>üì¶express-gql-api\\\\n‚î£ üìÇsrc\\\\n‚î£ üìú.gitignore\\\\n‚î£ üìúReadme.md\\\\n‚î£ üìúpackage.json\\\\n‚îó üìútsconfig.json\\\\n</code></pre>\\\\n<p>However, let&#39;s add some files in the <code>src</code> folder first\\\\nCreate an empty directory in the <code>src</code> folder called <code>data</code> - this is where we willl be placing out database connectors, types, schemas and resolver files.\\\\nCreate the following files to match the following structure:</p>\\\\n<pre><code>üì¶express-gql-api\\\\n‚î£ üìÇsrc\\\\n‚îÉ ‚î£ üìÇdata\\\\n‚îÉ ‚îÉ ‚î£ üìúdb.ts\\\\n‚îÉ ‚îÉ ‚î£ üìúresolvers.ts\\\\n‚îÉ ‚îÉ ‚î£ üìúschema.ts\\\\n‚îÉ ‚îÉ ‚îó üìútypes.ts\\\\n‚îÉ ‚îó üìúindex.ts\\\\n‚î£ üìúReadme.md\\\\n‚î£ üìúpackage.json\\\\n‚îó üìútsconfig.json\\\\n</code></pre>\\\\n<h3 id=\\\\\\\"schema-definition\\\\\\\">Schema Definition</h3>\\\\n<p>GraphQL requires a schema to be defined. A schema what graphQL uses to know what type of data to expect.</p>\\\\n<br />\\\\nWe will define the schema in the `schema.ts` file in the following way: We will use our graphQL endpoint to create and query a user. So we need\\\\nto define:\\\\n\\\\n<ul>\\\\n<li><p>a <code>user</code> type</p>\\\\n</li>\\\\n<li><p>a <code>UserInput</code> input - that has the same structure as the <code>User</code> type</p>\\\\n</li>\\\\n<li><p>a <code>Query</code> type - where we will define all the queries</p>\\\\n</li>\\\\n<li><p>a <code>Mutation</code> type - where we will define the mutations</p>\\\\n<pre><code class=\\\\\\\"language-ts\\\\\\\">import { resolvers } from &#39;./resolvers&#39;\\\\nimport { makeExecutableSchema } from &#39;graphql-tools&#39;\\\\n\\\\nconst typeDefs = `\\\\n    type User {\\\\n      name: String\\\\n      username: String\\\\n    }\\\\n    input UserInput {\\\\n      name: String\\\\n      username: String\\\\n    }\\\\n    type Query {\\\\n      getUser(username: String): User\\\\n    }\\\\n    type Mutation{\\\\n      createUser(user: UserInput): User\\\\n    }\\\\n  `\\\\n// Build the schema and export\\\\nconst schema = makeExecutableSchema({ typeDefs, resolvers })\\\\nexport { schema }\\\\n</code></pre>\\\\n</li>\\\\n</ul>\\\\n<h3 id=\\\\\\\"definine-the-type---typets\\\\\\\">Definine the type - <code>type.ts</code></h3>\\\\n<pre><code class=\\\\\\\"language-ts\\\\\\\">export class UserType {\\\\n  constructor(public name: String, public username: String) {}\\\\n}\\\\n</code></pre>\\\\n<h3 id=\\\\\\\"connecting-the-database\\\\\\\">Connecting the Database</h3>\\\\n<h4 id=\\\\\\\"setting-up-the-mongodb-instance-üóÑÔ∏è\\\\\\\">Setting up the MongoDB instance üóÑÔ∏è</h4>\\\\n<p>Before we move into this step, we will need to first set up our database. One can do so by following this process:</p>\\\\n<ol>\\\\n<li>create a free MongoDB account <a href=\\\\\\\"https://account.mongodb.com/account/login\\\\\\\">here</a></li>\\\\n<li>Create a <strong>free</strong> cluster.</li>\\\\n<li>Once the cluster has been created, click <code>connect</code> to your cluster. Further instructions can be found <a href=\\\\\\\"https://docs.atlas.mongodb.com/connect-to-cluster/\\\\\\\">here</a></li>\\\\n<li>You will need to add a connection IP address - typically your own IP for development locally</li>\\\\n<li>create a database user with a username and password - You will need this to login to your database later</li>\\\\n<li>Proceed to choosing a connection method - in our case we will use the <code>connect your application</code> option</li>\\\\n<li>This will lead us to a page to select our driver and version - which in our case should be <code>Node.js</code> Version <code>3.6 or later</code>.</li>\\\\n<li>Copy your connection string somewhere safe that you can edit. You will notice that the username is included in the connection string but you will need to replace the <code>&lt;password&gt;</code> with your password and also pick a name for our database\\\\n{&#39; &#39;}<br />\\\\nAssuming our username was `amani` with password `AEDPfTeq61WH04NL`, and we want our database to be called `bliss`, our connection string would\\\\nlook like:</li>\\\\n</ol>\\\\n<pre><code class=\\\\\\\"language-txt\\\\\\\">mongodb+srv://amani:AEDPfTeq61WH04NL@cluster0.9ntf0.mongodb.net/bliss?retryWrites=true&amp;w=majority\\\\n</code></pre>\\\\n<ol start=\\\\\\\"9\\\\\\\">\\\\n<li>Save this connection string somewhere where you can reference it later as we will need it when running our program.</li>\\\\n</ol>\\\\n<h4 id=\\\\\\\"connecting-to-the-database-programmatically---dbts\\\\\\\">Connecting to the Database programmatically - <code>db.ts</code></h4>\\\\n<p>In the <code>db.js</code> file, we will import <code>mongoose</code> and then define a new schema for the database - in our case, the only schema we will need is the user schema.</p>\\\\n<br />\\\\nWe will then create a new mongoose model that will be exported for use to query the database. Notice that we have set the `connectionString`\\\\nvariable to an environment variable - this is safer than pasting the connection string right into your code because it makes your database vulnerable.\\\\nIn our case, will set the connection string to an environment varible when we are ready to run the application.\\\\n\\\\n<pre><code class=\\\\\\\"language-ts\\\\\\\">import mongoose from &#39;mongoose&#39;\\\\nconst Schema = mongoose.Schema\\\\n\\\\n// @ts-ignore\\\\nconst connectionString: String = process.env.MONGO_DB\\\\n// @ts-ignore\\\\nmongoose.connect(connectionString, {\\\\n  useNewUrlParser: true,\\\\n  useUnifiedTopology: true,\\\\n  useFindAndModify: false,\\\\n  useCreateIndex: true\\\\n})\\\\n\\\\nconst UserSchema = new Schema({\\\\n  name: String,\\\\n  username: String\\\\n})\\\\n\\\\nconst User = mongoose.model(&#39;User&#39;, UserSchema)\\\\n\\\\nexport { User }\\\\n</code></pre>\\\\n<h3 id=\\\\\\\"declaring-the-resolvers---resolversts\\\\\\\">Declaring the resolvers - <code>resolvers.ts</code></h3>\\\\n<p>The resolvers are the functions that are run whenever the endpoint is run - so you need to define a function for each query and mutation as we will do below:</p>\\\\n<pre><code class=\\\\\\\"language-ts\\\\\\\">import { UserType } from &#39;./types&#39;\\\\n\\\\n// import the User from the database\\\\nimport { User } from &#39;./db&#39;\\\\n\\\\nexport const resolvers = {\\\\n  Query: {\\\\n    //@ts-ignore\\\\n    getUser: (root, { username }) =&gt; {\\\\n      return User.findOne({ username: username })\\\\n        .then((user: UserType) =&gt; {\\\\n          return user\\\\n        })\\\\n        .catch((error: any) =&gt; {\\\\n          console.log(error.message)\\\\n        })\\\\n    }\\\\n  },\\\\n  Mutation: {\\\\n    // @ts-ignore\\\\n    createUser: async (root, { user }) =&gt; {\\\\n      const newUser = new User({ name: user.name, username: user.username })\\\\n      await newUser.save()\\\\n      return newUser\\\\n    }\\\\n  }\\\\n}\\\\n</code></pre>\\\\n<h2 id=\\\\\\\"piece-the-pie-together-ü•ß---indexts\\\\\\\">Piece the pie together ü•ß - <code>index.ts</code></h2>\\\\n<p>Our <code>index.ts</code> file is where all the majic happens. We will begin by importing the necessary packages and instantiating a new express app. Then we will initialize the connection to the database and attach the <code>grapqlHTTP</code> middleware function with our schema and <code>graphiql</code> - which we can use to explore the api:</p>\\\\n<pre><code class=\\\\\\\"language-ts\\\\\\\">import express from &#39;express&#39;\\\\nimport { graphqlHTTP } from &#39;express-graphql&#39;\\\\nimport { schema } from &#39;./data/schema&#39;\\\\n\\\\n// Initialize app\\\\nconst app = express()\\\\nrequire(&#39;./data/db&#39;)\\\\n\\\\n// the graphQL endpoint at /graphql.\\\\napp.use(&#39;/graphql&#39;, graphqlHTTP({ schema: schema, graphiql: true }))\\\\n\\\\napp.get(&#39;*&#39;, (req, res) =&gt; {\\\\n  res.json({ message: &#39;Welcome to the api&#39; })\\\\n})\\\\n\\\\nconst PORT = 7000\\\\napp.listen(PORT, () =&gt; {\\\\n  console.log(`api is running on port ${PORT}`)\\\\n})\\\\n</code></pre>\\\\n<h2 id=\\\\\\\"running-the-server\\\\\\\">Running the server</h2>\\\\n<p>Before we run the server, we will need to add our mongoDB connection string to the environment variables:</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">  export MONGO_DB=&#39;mongodb+srv://amani:AEDPfTeq61WH04NL@cluster0.9ntf0.mongodb.net/bliss?retryWrites=true&amp;w=majority&#39;\\\\n</code></pre>\\\\n<p>Now, we are ready to run the server üöÄ</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">  npm run start\\\\n</code></pre>\\\\n<p>And we can run the server and explore our api.\\\\nHere&#39;s an example of a mutation that you can make with the api:</p>\\\\n<h3 id=\\\\\\\"mutation\\\\\\\">Mutation</h3>\\\\n<p>We can add a user by making a mutation on the api:</p>\\\\n<pre><code class=\\\\\\\"language-txt\\\\\\\">  mutation createUser ($input:UserInput){\\\\n    createUser(user:$input) {\\\\n      name\\\\n      username\\\\n    }\\\\n  }\\\\n</code></pre>\\\\n<p>We can then pass in the user input using the query variables:</p>\\\\n<pre><code class=\\\\\\\"language-txt\\\\\\\">  {\\\\n    &quot;input&quot;: {\\\\n      &quot;name&quot;: &quot;Laurence&quot;,\\\\n      &quot;username&quot;: &quot;laudebugs&quot;\\\\n    }\\\\n  }\\\\n</code></pre>\\\\n<p>Here&#39;s how the mutation looks like:</p>\\\\n<p>&lt;img src={&#39;<a href=\\\\\\\"https://raw.githubusercontent.com/lbugasu/articles/main/resources/graphqlmutation.png&#39;%7D\\\\\\\">https://raw.githubusercontent.com/lbugasu/articles/main/resources/graphqlmutation.png&#39;}</a> width={&#39;100%&#39;} /&gt;</p>\\\\n<h3 id=\\\\\\\"query\\\\\\\">Query</h3>\\\\n<p>If we were to then ask the api for a certain user, we can make the query by:</p>\\\\n<pre><code class=\\\\\\\"language-txt\\\\\\\">  query {\\\\n    getUser (username:&quot;laudebugs&quot;){\\\\n      name\\\\n    }\\\\n  }\\\\n</code></pre>\\\\n<p>You can check out the <a href=\\\\\\\"https://github.com/lbugasu/express-gql-api\\\\\\\">repo here</a></p>\\\\n<h3 id=\\\\\\\"common-issues-that-you-may-run-into\\\\\\\">Common Issues that you may run into:</h3>\\\\n<ol>\\\\n<li><strong>IP isn&#39;t whitelisted</strong>: If you&#39;re running into this issue, it may be the case that your ip address has changed and you need to add your current IP to be able to connect.</li>\\\\n<li><strong>Could not find a declaration file for &#39;express&#39;</strong>\\\\nInstall the declaratio file for <code>express</code>:</li>\\\\n</ol>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">    npm i --save-dev express\\\\n</code></pre>\\\\n<h2 id=\\\\\\\"further-reading\\\\\\\">Further Reading</h2>\\\\n<ul>\\\\n<li><a href=\\\\\\\"https://medium.com/atheros/graphql-quick-tip-how-to-pass-variables-into-a-mutation-in-graphiql-23ecff4add57\\\\\\\">GraphQL quick tip: How to pass variables in GraphiQL</a></li>\\\\n</ul>\\\\n\\\",\\n            \\\"url\\\": \\\"https://www.laudebugs.me/dev/build-graphql-api-in-typescript\\\",\\n            \\\"title\\\": \\\"How To: Build an Express GraphQL API in TypeScript\\\",\\n            \\\"summary\\\": \\\"Learn how to build a Node.js GraphQL API with Express and TypeScript\\\",\\n            \\\"image\\\": \\\"https://www.laudebugs.me/post-images/build-graphql-api-in-typescript.jpg\\\",\\n            \\\"date_modified\\\": \\\"2021-02-23T00:00:00.000Z\\\",\\n            \\\"author\\\": {\\n                \\\"name\\\": \\\"Laurence B. Ininda\\\",\\n                \\\"url\\\": \\\"https://www.laudebugs.me/\\\"\\n            }\\n        },\\n        {\\n            \\\"content_html\\\": \\\"<h2 id=\\\\\\\"foreground\\\\\\\">Foreground</h2>\\\\n<p>The internet is a vast ‚Äúland‚Äù with plenty of room to create, share and find content. Internet usage in Kenya is increasing by the year. COVID-19 brought to the forefront, the importance of having an online presence. Companies like Amazon, that were internet-first, widened their market share of internet sales and became more relevant. Those companies that didn‚Äôt have an online presence realized that they needed to adapt quickly to the times. Even people realized that they needed to build an online presence to showcase their work or seek jobs.</p>\\\\n<p>In developing countries like Kenya, with companies shifting online, there is a growing need to track these trends. However, data is still expensive for the average Kenyan even though data consumption in the country has been increasing by the year. Therefor, in as much as companies are moving online, they need to take into consideration this very fact that accessing websites should not require a large amount of data ‚Äì say more than 2MB (to be revised later). And web developers need to be creative in ways that they can reduce data consumption on subsequent website visits to the sites they build. For instance, through caching or giving users a low-data version of their site once they land on the page before loading any subsequent content.</p>\\\\n<h2 id=\\\\\\\"conceptualization\\\\\\\">Conceptualization</h2>\\\\n<p>Through¬†this¬†project,¬†I¬†would¬†like¬†to¬†accomplish¬†two¬†things:</p>\\\\n<ul>\\\\n<li>Create¬†a¬†directory¬†of¬†Kenyan¬†websites - websites¬†with¬†extensions¬†‚Äú.co.ke‚Äù¬†or¬†‚Äú.ke‚Äù or that include¬†‚Äúkenya‚Äù¬†within the domain¬†name.</li>\\\\n<li>Of¬†the¬†collected¬†sites,¬†note¬†how¬†much¬†data¬†is¬†downloaded¬†on¬†the¬†landing¬†page of¬†the site¬†and¬†organize¬†this¬†data¬†into¬†a¬†repository.</li>\\\\n</ul>\\\\n<h2 id=\\\\\\\"data-collection-and-preparation\\\\\\\">Data Collection and Preparation</h2>\\\\n<p>How many websites can I find by randomly searching common words and the big companies in Kenya?</p>\\\\n<p>After considering this, I searched the internet to try to find a difinitive list of websites in Kenya. To find this list, I would have to contact organizations like The Kenya Network Information Centre (KENIC) to obtain this information. And although this seemed like the route to go, I also found a list of the top 500 websites in Kenya provided by Alexa and figured that this list would be more useful to use as a baseline of websites in Kenya. And as the list showed, there&#39;s a large number of domains that do not end with .co.ke or .ke that Kenyans use. After signing up for the free trial, I parsed the data to this json file using a simple java script.</p>\\\\n<p>Considering all the information that lighthouse provided, two metrics seemed important: the performance of the site as well as the amount of data downloaded when a user accesses the website., i.e. Total size.\\\\nTwo metrics: Performance and total size downloaded on page load\\\\nThe size will vary from device to device since mobile devices might have cached the websites before or CDN&#39;s might be used to deliver a faster and smaller payload.</p>\\\\n<h3 id=\\\\\\\"why-lighthouse\\\\\\\">Why lighthouse?</h3>\\\\n<p>Google provides Lighthouse as a developer tool to generate a report on a website. The tool is also available as a commandline interface tool. However, I wanted to use the tool as part of a node.js project. Therefore, I stumbled on this project by Sahava on github from which I borrowed heavily and modified to my own use.\\\\nGenerating¬†the¬†Reports</p>\\\\n<p>Since my computer crawled at even the thought of running lighthouse on 500 websites, I decided to run the runLightHouse.js script on AWS.\\\\nHere are the steps for creating an AWS instance:\\\\nAfter Creating an Amazon AWS account,\\\\nCreate an EC2 instance. You can proceed with launching an instance that contains the free tier.</p>\\\\n<pre><code>Launch instance &gt; Ubuntu 20.04 (with Free tier eligible) &gt; General Purpose Instance Type &gt; Choose an Existing Key-pair for ssh into your instance or download a new instance &gt;Launch instance\\\\n</code></pre>\\\\n<p>I however created an instance type with a GPU (just for fun) and to perform lighthouse processes fast. (this cost a couple of cents/hr)\\\\nSSH into your instance:</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\"># move your .pem file into the come folder\\\\n# Assuming you downloaded the .pem file to the downloads folder:\\\\n# cd into the root directory\\\\ncd\\\\n# check whether a .ssh folder exists\\\\nls -al\\\\n# if it doesn&#39;t, create the folder\\\\nmkdir .ssh\\\\n#move the .pem file into the .ssh folder. Here assume I call my .pem file myKeyPair\\\\nmv [path where the .pem file exists]/myKeyPair.pem myKeyPair.pem\\\\n# change the permissions of the .pem file\\\\nchmod 400 .ssh/myKeyPair.pem\\\\n</code></pre>\\\\n<p>Copy your Public DNS (IPv4) from your AWS instance - this is usually located at your instances page when you click on your instance</p>\\\\n<p>SSH into your instance</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\"># replace [my public ip with the actual ip]\\\\nssh -i ~/.ssh/myKeyPair.pem ubuntu@[Public DNS (IPv4)]\\\\n# you may be asked whether to type yes or no to proceed. Type yes to proceed\\\\n\\\\n# Prepare the server to run your script\\\\ninstall git\\\\nsudo apt install git -y\\\\n# Install latest version of npm\\\\ncurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash\\\\nsudo apt-get install -y nodejs\\\\n# Install Chrome. I referenced this article\\\\n\\\\n# Download Google chrome\\\\nwget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\\\\n# install google chrome\\\\nsudo apt install ./google-chrome-stable_current_amd64.deb\\\\n</code></pre>\\\\n<h3 id=\\\\\\\"running-the-script\\\\\\\">Running the script</h3>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\"># Clone the repo\\\\ngit clone https://github.com/lbugasu/kenya-web-project.git\\\\n\\\\n# enter project folder\\\\ncd kenya-web-project\\\\n\\\\n# Install packages\\\\nnpm i\\\\n\\\\n# Run the script\\\\nnode generateReports.js\\\\n# Exit the AWS instance\\\\n</code></pre>\\\\n<h2 id=\\\\\\\"update\\\\\\\">Update</h2>\\\\n<p>I tried running the script on an amazon linux server but there was always an error generated, so I switched to using an ubuntu 20.04 instance.\\\\nBelow are the instructions fro setting up and to ssh into an Amazon linux ec2 instance:\\\\nAfter Creating an Amazon AWS account,\\\\nCreate an EC2 instance. You can proceed with launching an instance that contains the free tier.</p>\\\\n<pre><code class=\\\\\\\"language-text\\\\\\\">Launch instance &gt; Amazon Linux (with Free tier eligible) &gt; General Purpose Instance Type &gt; Choose an Existing Key-pair for ssh into your instance or download a new instance &gt;Launch instance\\\\n</code></pre>\\\\n<p>I however created an instance type with a GPU (just for fun) and to perform lighthouse processes fast. (this cost a couple of cents/hr)\\\\nSSH into your instance:</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\"># move your .pem file into the come folder\\\\n# Assuming you downloaded the .pem file to the downloads folder:\\\\n# cd into the root directory\\\\ncd [root directory]\\\\n\\\\n# check whether a .ssh folder exists\\\\nls -al\\\\n\\\\n# if it doesn&#39;t, create the folder\\\\nmkdir .ssh\\\\n#move the .pem file into the .ssh folder. Here assume I call my .pem file myKeyPair\\\\nmv [path where the .pem file exists]/myKeyPair.pem myKeyPair.pem\\\\n\\\\nChange the permissions of the .pem file\\\\n```bash\\\\nchmod 400 .ssh/myKeyPair.pem\\\\n</code></pre>\\\\n<p>Copy your Public DNS (IPv4) from your AWS instance - this is usually located at your instances page when you click on your instance</p>\\\\n<pre><code>SSH into your instance\\\\n```bash\\\\n# replace [my public ip with the actual ip]\\\\nssh -i ~/.ssh/myKeyPair.pem ec2-user@[Public DNS (IPv4)]\\\\n</code></pre>\\\\n<p>You may be asked whether to type yes or no to proceed. Type yes to proceed</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\"># Prepare the server to run your script\\\\n# install git\\\\nsudo yum install git -y\\\\n</code></pre>\\\\n<p>install npm using Amazon&#39;s instructions</p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\"># Install latest version of npm\\\\nnpm install -g npm@latest\\\\n# Install Chrome. I referenced this article\\\\ncurl https://intoli.com/install-google-chrome.sh | bash\\\\n</code></pre>\\\\n<h4 id=\\\\\\\"running-the-script-1\\\\\\\">Running the script</h4>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">#Clone the repo\\\\ngit clone https://github.com/lbugasu/kenya-web-project.git\\\\n\\\\n# enter project folder\\\\n```bash\\\\ncd kenya-web-project\\\\n# Install packages\\\\nnpm i\\\\n# Exit the AWS instance\\\\nexit\\\\n</code></pre>\\\\n<h2 id=\\\\\\\"analysis\\\\\\\">Analysis</h2>\\\\n<p>Having obtained two additional metrics of each website, i.e. the performance and size of page downloaded, then we can plot several graphs to gauge how one metric affects the other.</p>\\\\n<p>In order to answer questions that the data presented, there still remained missing pieces of information that would enable me to analyze the data accurately. With metrics such as performance, size of webpage downloaded and average time spent on a website, we could take a look at the general trend of the top websites in Kenya as shown below.</p>\\\\n<p>&lt;img\\\\n  alt=&quot;Size of the web page downloaded&quot;\\\\n  src={&#39;<a href=\\\\\\\"https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/Size%20of%20the%20web%20page%20downloaded.png&#39;%7D\\\\\\\">https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/Size%20of%20the%20web%20page%20downloaded.png&#39;}</a>\\\\n  width={&#39;100%&#39;}\\\\n/&gt;</p>\\\\n<p>The optimal size of a web page is 0 - 1 MB downloaded once a use logs onto a site. This is of course, not taking into account cached resources that might reduce the size of the page downloaded.</p>\\\\n<p>&lt;img\\\\n  alt=&quot;TimeSpentOnWebsite&quot;\\\\n  src={&#39;<a href=\\\\\\\"https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/TimeSpentOnWebsite.png&#39;%7D\\\\\\\">https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/TimeSpentOnWebsite.png&#39;}</a>\\\\n  width={&#39;100%&#39;}\\\\n/&gt;</p>\\\\n<p>The modal time spent on a website by Kenyans is 3 minutes with the average coming to 7.2682 minutes.</p>\\\\n<h2 id=\\\\\\\"postscript\\\\\\\">Postscript</h2>\\\\n<p>In analyzing the dataset, there&#39;s a temptation to draw immediate conclusions from the various datapoints such as comparing the time spent and how this changes based on the size of the web page downloaded when a user accesses the website. However, this analysis doesn&#39;t take into account the fact that different websites serve different functions. For instance, a person logging into the Kenya Revenue Authority website would perhaps use the site for a specific predetermined use case while a person using YouTube might not have a goal in mind while using the site. And therefore one would need to make assumptions to immediately draw conclusions from the data. On modelling the graph, the size of the page downloaded doesn&#39;t relate to how much time is spent on the site.\\\\nFurther information is needed to ask deeper questions from the dataset. One such piece is the genre of the website which would be able to draw distinctions between the different websites and make comparisons within websites of a certain type.\\\\nAs of now, the dataset is freely available to use and for more research to be done. Especially at a time when the internet is crucial to keep systems moving during Covid-19, we need to examine more closely how Kenyans use the internet.\\\\nHiccups along the way\\\\nIn generating the lighthouse reports for the site, I decided to splice the list of websites into groups of 30 websites at a time - because even AWS servers weren&#39;t running all the reports smoothly. At other times, I ran 50 reports at a time. However, while doing this, I realised I skipped over close to 70 websites spread over my input set of 500. And so, I wrote a small python script to find the missing sites.\\\\nI had to manually run the website Bet365.com using the lighthouse cli because the node script kept timing out</p>\\\\n<h3 id=\\\\\\\"after-installing-lighthouse\\\\\\\">After installing lighthouse</h3>\\\\n<p><code>npm install -g lighthouse</code></p>\\\\n<pre><code class=\\\\\\\"language-bash\\\\\\\">lighthouse https://www.bet365.com/ --quiet --output json --output-path ./www_Bet365_com.json\\\\n</code></pre>\\\\n<h3 id=\\\\\\\"references\\\\\\\">References</h3>\\\\n<ul>\\\\n<li><a href=\\\\\\\"https://github.com/sahava/multisite-lighthouse\\\\\\\">Multisite Lighthouse</a></li>\\\\n<li><a href=\\\\\\\"https://www.alexa.com/topsites/countries/KE\\\\\\\">Top Sites in Kenya</a></li>\\\\n<li>Google Chrome Lighthouse <a href=\\\\\\\"https://github.com/GoogleChrome/lighthouse\\\\\\\">Github Repository</a></li>\\\\n</ul>\\\\n<p>-&gt; Checkout the <a href=\\\\\\\"https://github.com/lbugasu/kenya-web-project\\\\\\\">Github Repository</a></p>\\\\n\\\",\\n            \\\"url\\\": \\\"https://www.laudebugs.me/dev/kenya-web-project\\\",\\n            \\\"title\\\": \\\"Kenya Web Project\\\",\\n            \\\"summary\\\": \\\"Examining performance and data download sizes of Kenya's top 500 websites. Expecially in emerging markets, website developers need to build small and efficient web applications.\\\",\\n            \\\"image\\\": \\\"https://www.laudebugs.me/post-images/kenya-web-project.jpg\\\",\\n            \\\"date_modified\\\": \\\"2020-06-05T00:00:00.000Z\\\",\\n            \\\"author\\\": {\\n                \\\"name\\\": \\\"Laurence B. Ininda\\\",\\n                \\\"url\\\": \\\"https://www.laudebugs.me/\\\"\\n            }\\n        }\\n    ]\\n}\"",
    "atom": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<feed xmlns=\"http://www.w3.org/2005/Atom\">\n    <id>https://www.laudebugs.me/</id>\n    <title>Lau de Bugs' Blog</title>\n    <updated>2021-11-12T19:49:33.348Z</updated>\n    <generator>awesome</generator>\n    <author>\n        <name>Laurence B. Ininda</name>\n        <email>lbugasu@gmail.com</email>\n        <uri>https://www.laudebugs.me/</uri>\n    </author>\n    <link rel=\"alternate\" href=\"https://www.laudebugs.me/api/rss\"/>\n    <link rel=\"self\" href=\"https://www.laudebugs.me/api/rss/atom\"/>\n    <subtitle>Life and Software Development Blog</subtitle>\n    <logo>https://www.laudebugs.me/images/logos/logo_light.png</logo>\n    <icon>https://www.laudebugs.me/favicon.ico</icon>\n    <rights>All rights reserved 2021, Lau de Bugs</rights>\n    <category term=\"github\"/>\n    <category term=\"api\"/>\n    <category term=\"database\"/>\n    <category term=\"express\"/>\n    <category term=\"graphql\"/>\n    <category term=\"typescript\"/>\n    <category term=\"lighthouse\"/>\n    <category term=\"node.js\"/>\n    <category term=\"python\"/>\n    <entry>\n        <title type=\"html\"><![CDATA[Using your GitHub Repository as a Database]]></title>\n        <id>https://www.laudebugs.me/dev/using-your-github-repository-as-a-database</id>\n        <link href=\"https://www.laudebugs.me/dev/using-your-github-repository-as-a-database\"/>\n        <updated>2021-03-01T00:00:00.000Z</updated>\n        <summary type=\"html\"><![CDATA[You don't have to look far for somewhere to store your content. GitHub is a great place to store your content. Together with the GitHub API, you can use GitHub make this happen.]]></summary>\n        <content type=\"html\"><![CDATA[<h1 id=\"how-to-use-your-repo-as-a-database-with-the-github-graphql-api\">How To: Use your Repo as a Database with the Github GraphQL API</h1>\n<blockquote>\n<p>You can sort of use your Github repository as a database for your blog posts by leveraging the Github <a href=\"https://docs.github.com/en/graphql\">Graph QL API</a> üò±.</p>\n</blockquote>\n<h2 id=\"motivation\">Motivation</h2>\n<p>The Github GraphQL API provides a lot more capabilities than I can cover in one <em>snack</em>.</p>\n<p>However, in searching for a way to share the small lessons that I pick up week in week out, I knew that publishing through <a href=\"https://www.contentful.com/\">Contentful</a>, which it the CMS, I use for the main content in my blog site, was a little too much to share easily and quicly.\nPosting on Github and sharing that as <a href=\"https://gist.github.com/lbugasu\">gists</a> seemed like I would be writing too much for a gist that is supposed to be a short code snippet - which was the original title of this section. Although <a href=\"https://gist.github.com/MichaelCurrin/6777b91e6374cdb5662b64b8249070ea\">MichaelCurrin</a> proves me otherwise! His article is what got me goint in the first place!</p>\n<h2 id=\"querying-the-graphql-api-for-posts\">Querying the GraphQL API for posts.</h2>\n<p>In order to use the Github GraphQL API, you can either use the <a href=\"https://docs.github.com/en/graphql/overview/explorer\">API explorer</a> by logging in through your github account, use an api testing tool like <a href=\"https://support.insomnia.rest/article/61-graphql\">Insomnia</a>, or you can use it programmatically.</p>\n<p>Since I was using the Apollo Graph QL library to query my backend - that helps me manage comments and likes, I began to do a little research on how to query the Github GraphQL API. I will link the articles below.\nThis <a href=\"https://stackoverflow.com/questions/58576940/how-to-handle-authorization-header-with-apollo-graphql\">stack overflow</a> answered how to add an authorization header to an Apollo Client Query.</p>\n<h2 id=\"the-query\">The Query</h2>\n<p>We will be using writing our query in a node.js environment using both <a href=\"https://github.com/apollographql/apollo-client\">Apollo Client</a> and <a href=\"https://github.com/axios/axios\">Axios</a></p>\n<h3 id=\"1-obtain-your-github-public-access-token\">1. Obtain your github public access token</h3>\n<p>The only permission you need for this task is <code>public_repo</code> under <code>repo</code>:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> repo<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> public_repo</li>\n</ul>\n</li>\n</ul>\n<p>Give your token a name and will look something like this:</p>\n<pre><code class=\"language-txt\">89fdd35bcd40787b519e97462cec0f9975a66a58\n</code></pre>\n<p>Note the token above is revoked and you&#39;ll need to generate yours. Once you&#39;re done, we&#39;re ready for the next step!</p>\n<h3 id=\"2-querying-the-repo\">2. Querying the repo</h3>\n<p>In my case, I will be looking for files in my repository called <code>articles</code>. If you&#39;d like to use your own repository, simply make note of your repository name.</p>\n<h3 id=\"using-the-apollo-client\">Using the Apollo Client</h3>\n<ol>\n<li><p>Install the Apollo client</p>\n<pre><code class=\"language-bash\">npm install @apollo/client graphql\n</code></pre>\n</li>\n<li><p>Working in your js file, import the Apollo client and a few methods that we will make use of:</p>\n<pre><code class=\"language-js\">import { ApolloClient, InMemoryCache, gql, ApolloLink, HttpLink } from &#39;@apollo/client&#39;\n</code></pre>\n</li>\n<li><p>Initialize a new apollo client with the github graphQL endpoint and your token</p>\n<pre><code class=\"language-js\">const token = &#39;89fdd35bcd40787b519e97462cec0f9975a66a58&#39;\n\nconst endpoint = &#39;https://api.github.com/graphql&#39;\n\n// Add the toke to the header of your client for all your requests\nconst githubLClient = new ApolloClient({\n  uri: endpoint,\n  headers: {\n    authorization: `Bearer ${token}`\n  },\n  cache: new InMemoryCache({\n    addTypename: false\n  })\n})\n</code></pre>\n</li>\n<li><p>Make the query\nI referenced github user <a href=\"https://gist.github.com/int128/b0e75e3043c8a33808cea0089d988ed3\">int128&#39;s gist</a> for the structure of the graphQl query:</p>\n<pre><code class=\"language-js\">let request = await githubClient.query({\n  query: gql`\n    {\n      repository(owner: &quot;lbugasu&quot;, name: &quot;articles&quot;) {\n        defaultBranchRef {\n          target {\n            ... on Commit {\n              file(path: &quot;/&quot;) {\n                type\n                object {\n                  ... on Tree {\n                    entries {\n                      name\n                      object {\n                        ... on Blob {\n                          text\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  `\n})\n</code></pre>\n</li>\n<li><p>Parse your output to obtain the file&#39;s contents.\nBy making this same query on Github&#39;s GraphQL explorer, the data returned, which is essentially a json object, at the time of writing this, looks like this:</p>\n<pre><code class=\"language-json\">{\n  &quot;data&quot;: {\n    &quot;repository&quot;: {\n      &quot;defaultBranchRef&quot;: {\n        &quot;target&quot;: {\n          &quot;file&quot;: {\n            &quot;type&quot;: &quot;tree&quot;,\n            &quot;object&quot;: {\n              &quot;entries&quot;: [\n                {\n                  &quot;name&quot;: &quot;QraphQL.md&quot;,\n                  &quot;object&quot;: {\n                    &quot;text&quot;: &quot;# Exploring GraphQL\\n&quot;\n                  }\n                },\n                {\n                  &quot;name&quot;: &quot;README.md&quot;,\n                  &quot;object&quot;: {\n                    &quot;text&quot;: &quot;# Articles&quot;\n                  }\n                }\n              ]\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>So, if to obtain the entries, we would access them by:</p>\n<pre><code class=\"language-js\">let result = request.data.repository.defaultBranchRef.target.file.type.object.entries\n</code></pre>\n</li>\n</ol>\n<h4 id=\"using-axios\">Using Axios</h4>\n<ol>\n<li><p>Install the <a href=\"https://github.com/axios/axios\">axios npm package</a></p>\n<pre><code class=\"language-bash\">npm install axios\n</code></pre>\n</li>\n<li><p>Import exios into your node project:</p>\n<pre><code class=\"language-js\">import axios from &#39;axios&#39;\n</code></pre>\n</li>\n<li><p>initialize an authentication object and the query string that will be attatched to your request</p>\n<pre><code class=\"language-js\">// The Authorization in the header of the request\nconst oauth = { Authorization: &#39;bearer &#39; + token }\n\n// The Query String\nconst query = `\n        {\n          repository(owner: &quot;lbugasu&quot;, name: &quot;articles&quot;) {\n            defaultBranchRef {\n              target {\n                ... on Commit {\n                  file(path: &quot;/&quot;) {\n                    type\n                    object {\n                      ... on Tree {\n                        entries {\n                          name\n                          object {\n                            ... on Blob {\n                              text\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      `\n</code></pre>\n</li>\n<li><p>Make the request, adding in the query and the header</p>\n<pre><code class=\"language-js\">let request = axios.post(githubUrl, { query: query }, { headers: oauth })\n</code></pre>\n</li>\n<li><p>Parse your output as above:</p>\n<pre><code class=\"language-js\">let result = request.data.repository.defaultBranchRef.target.file.type.object.entries\n</code></pre>\n</li>\n</ol>\n<h2 id=\"referenced-articles\">Referenced articles</h2>\n<ul>\n<li><a href=\"https://gist.github.com/MichaelCurrin/6777b91e6374cdb5662b64b8249070ea\">Graph QL query</a> for getting files.</li>\n<li><a href=\"https://support.insomnia.rest/article/61-graphql\">GraphQL Queries using Insomnia</a></li>\n<li>How to create a personal access token from your github account: <a href=\"https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token\">Creating a personal access token</a></li>\n<li><a href=\"https://medium.com/risan/set-authorization-header-with-apollo-client-e934e6517ccf\">Set Authorization Header with Apollo Client</a></li>\n<li><a href=\"https://stackoverflow.com/questions/58576940/how-to-handle-authorization-header-with-apollo-graphql\">How to handle authorization header with apollo graphql? - Stack Overflow</a></li>\n<li><a href=\"https://dev.to/thomasaudo/get-started-with-github-grapql-api--1g8b\">Get started with GitHub GraphQL API üë®‚Äçüî¨</a> on Dev</li>\n</ul>\n]]></content>\n        <author>\n            <name>Laurence B. Ininda</name>\n            <email>lbugasu@gmail.com</email>\n            <uri>https://www.laudebugs.me/</uri>\n        </author>\n        <contributor>\n            <name>Laurence B. Ininda</name>\n            <email>lbugasu@gmail.com</email>\n            <uri>https://www.laudebugs.me/</uri>\n        </contributor>\n    </entry>\n    <entry>\n        <title type=\"html\"><![CDATA[How To: Build an Express GraphQL API in TypeScript]]></title>\n        <id>https://www.laudebugs.me/dev/build-graphql-api-in-typescript</id>\n        <link href=\"https://www.laudebugs.me/dev/build-graphql-api-in-typescript\"/>\n        <updated>2021-02-23T00:00:00.000Z</updated>\n        <summary type=\"html\"><![CDATA[Learn how to build a Node.js GraphQL API with Express and TypeScript]]></summary>\n        <content type=\"html\"><![CDATA[<blockquote>\n<p>So you wanna write a node GraphQL backend in TypeScript? Well, Let&#39;s put all the pieces together and begin.</p>\n</blockquote>\n<h2 id=\"initilizing-the-project\">Initilizing the project</h2>\n<p>We&#39;ll be working in a terminal - be it the standalone teminal - or the integrated terminal in your text editor.</p>\n<ol>\n<li><p>Initialize a repository in an empty folder, say, we call ours <code>express-gql-api</code>.:</p>\n<pre><code class=\"language-bash\">mkdir express-gql-api\n\n# enter the project folder\ncd express-gql-api\n</code></pre>\n</li>\n<li><p>Initialize the folder as a node and git project:</p>\n<pre><code class=\"language-bash\">npm init -y\n\ngit init\n</code></pre>\n</li>\n<li><p>Initialize a Readme\nHaving a Readme is essential for any project - this is the document people will see when they come across your repository in Github.</p>\n<br />\nWe'll start off with a simple description but feel free to add more information about your project as you go. ```bash echo '# Express GraphQLAPI\nin TypeScript' > Readme.md ```</li>\n<li><p>Initalize the source directory\nThis is where we will place our <code>.ts</code> files</p>\n<pre><code class=\"language-bash\">mkdir src\n</code></pre>\n</li>\n</ol>\n<h2 id=\"typescript-and-project-setup\">TypeScript and Project SetUp</h2>\n<p>TypeScript is usually compiled to JavaScript and which is the code that is actually run.\nAssuming you already have the <a href=\"https://www.typescriptlang.org/id/download\">TypeScript</a> installed, we will write the configuration file that tells the TypeScript compiler how to compile out files into JavaScript:</p>\n<ol>\n<li><p>Initialize a <code>tsconfig.json</code> file in your root directory from the terminal</p>\n<pre><code class=\"language-bash\">tsc --init\n</code></pre>\n</li>\n<li><p>. Working in the text editor, we will set the following compiler options:</p>\n<ol>\n<li><p><code>&quot;rootDir&quot;</code> - this is the directory where the TypeScript compiler will search for <code>.ts</code> files to compile into JavaScript. In our case, the root directory is the <code>src</code> folder:</p>\n<pre><code class=\"language-json\">{\n  &quot;compilerOptions&quot;: {\n    //...\n    &quot;rootDir&quot;: &quot;./src&quot;\n    //...\n  }\n}\n</code></pre>\n</li>\n<li><p><code>&quot;outDir&quot;</code> - this is the directory where the compiled JavaScript will be placed:\nIn our case, we will call our output directory <code>&quot;dist&quot;</code></p>\n<pre><code class=\"language-json\">{\n  &quot;compilerOptions&quot;: {\n    //...\n    &quot;rootDir&quot;: &quot;./src&quot;,\n    &quot;ourDir&quot;: &quot;./dist&quot;\n    //...\n  }\n}\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>Finally, we will edit the package.json file so that we have a smooth time running the project. Add the following line under script in <code>package.json</code>:</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;:{\n  //...\n   &quot;start&quot; : &quot;nodemon dist/index.js&quot;,\n   //...\n}\n</code></pre>\n</li>\n</ol>\n<p>This is the basic setup that we need before we get started</p>\n<h2 id=\"setup\">SetUp</h2>\n<p>We will be working with a few packages that we need to install:</p>\n<ol>\n<li><a href=\"https://www.npmjs.com/package/express\"><code>express</code></a> - since we are buiding an express server</li>\n<li><a href=\"https://www.npmjs.com/package/express-graphql\"><code>express-graphql</code></a> - this is the express middleware that will allow us to build our graphQL endpoint</li>\n<li><a href=\"https://github.com/ardatan/graphql-tools#readme\"><code>graphql-tools</code></a> - A package that helps build the GraphQL Schema</li>\n<li><a href=\"https://www.npmjs.com/package/mongoose\"><code>mongoose</code></a> - The library that will allow us to connect to a MongoDB database</li>\n</ol>\n<p>Before we jump right into installing the packages, let&#39;s create a <code>.gitignore</code> file at the root folder and add <code>node_modules</code> so that git doesn&#39;t track npm packages:</p>\n<pre><code class=\"language-bash\">echo node_modules &gt; .gitignore\n</code></pre>\n<p>To install all the tools, we can do so in one command:</p>\n<pre><code class=\"language-bash\">npm i -s express express-graphql graphql-tools mongoose nodemon\n</code></pre>\n<p>Before we start writing some code, we need to have our TypeScript compiler running so that we can generate the JavaScript files as we go. So, in a separate window, run the typescript compiler with a watch flag:</p>\n<pre><code class=\"language-bash\">tsc -w\n</code></pre>\n<p>And now we are ready to build our api</p>\n<h2 id=\"the-api-ü•ë\">The API ü•ë</h2>\n<p>Let&#39;s add some files to our file structure first:</p>\n<pre><code>üì¶express-gql-api\n‚î£ üìÇsrc\n‚î£ üìú.gitignore\n‚î£ üìúReadme.md\n‚î£ üìúpackage.json\n‚îó üìútsconfig.json\n</code></pre>\n<p>However, let&#39;s add some files in the <code>src</code> folder first\nCreate an empty directory in the <code>src</code> folder called <code>data</code> - this is where we willl be placing out database connectors, types, schemas and resolver files.\nCreate the following files to match the following structure:</p>\n<pre><code>üì¶express-gql-api\n‚î£ üìÇsrc\n‚îÉ ‚î£ üìÇdata\n‚îÉ ‚îÉ ‚î£ üìúdb.ts\n‚îÉ ‚îÉ ‚î£ üìúresolvers.ts\n‚îÉ ‚îÉ ‚î£ üìúschema.ts\n‚îÉ ‚îÉ ‚îó üìútypes.ts\n‚îÉ ‚îó üìúindex.ts\n‚î£ üìúReadme.md\n‚î£ üìúpackage.json\n‚îó üìútsconfig.json\n</code></pre>\n<h3 id=\"schema-definition\">Schema Definition</h3>\n<p>GraphQL requires a schema to be defined. A schema what graphQL uses to know what type of data to expect.</p>\n<br />\nWe will define the schema in the `schema.ts` file in the following way: We will use our graphQL endpoint to create and query a user. So we need\nto define:\n\n<ul>\n<li><p>a <code>user</code> type</p>\n</li>\n<li><p>a <code>UserInput</code> input - that has the same structure as the <code>User</code> type</p>\n</li>\n<li><p>a <code>Query</code> type - where we will define all the queries</p>\n</li>\n<li><p>a <code>Mutation</code> type - where we will define the mutations</p>\n<pre><code class=\"language-ts\">import { resolvers } from &#39;./resolvers&#39;\nimport { makeExecutableSchema } from &#39;graphql-tools&#39;\n\nconst typeDefs = `\n    type User {\n      name: String\n      username: String\n    }\n    input UserInput {\n      name: String\n      username: String\n    }\n    type Query {\n      getUser(username: String): User\n    }\n    type Mutation{\n      createUser(user: UserInput): User\n    }\n  `\n// Build the schema and export\nconst schema = makeExecutableSchema({ typeDefs, resolvers })\nexport { schema }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"definine-the-type---typets\">Definine the type - <code>type.ts</code></h3>\n<pre><code class=\"language-ts\">export class UserType {\n  constructor(public name: String, public username: String) {}\n}\n</code></pre>\n<h3 id=\"connecting-the-database\">Connecting the Database</h3>\n<h4 id=\"setting-up-the-mongodb-instance-üóÑÔ∏è\">Setting up the MongoDB instance üóÑÔ∏è</h4>\n<p>Before we move into this step, we will need to first set up our database. One can do so by following this process:</p>\n<ol>\n<li>create a free MongoDB account <a href=\"https://account.mongodb.com/account/login\">here</a></li>\n<li>Create a <strong>free</strong> cluster.</li>\n<li>Once the cluster has been created, click <code>connect</code> to your cluster. Further instructions can be found <a href=\"https://docs.atlas.mongodb.com/connect-to-cluster/\">here</a></li>\n<li>You will need to add a connection IP address - typically your own IP for development locally</li>\n<li>create a database user with a username and password - You will need this to login to your database later</li>\n<li>Proceed to choosing a connection method - in our case we will use the <code>connect your application</code> option</li>\n<li>This will lead us to a page to select our driver and version - which in our case should be <code>Node.js</code> Version <code>3.6 or later</code>.</li>\n<li>Copy your connection string somewhere safe that you can edit. You will notice that the username is included in the connection string but you will need to replace the <code>&lt;password&gt;</code> with your password and also pick a name for our database\n{&#39; &#39;}<br />\nAssuming our username was `amani` with password `AEDPfTeq61WH04NL`, and we want our database to be called `bliss`, our connection string would\nlook like:</li>\n</ol>\n<pre><code class=\"language-txt\">mongodb+srv://amani:AEDPfTeq61WH04NL@cluster0.9ntf0.mongodb.net/bliss?retryWrites=true&amp;w=majority\n</code></pre>\n<ol start=\"9\">\n<li>Save this connection string somewhere where you can reference it later as we will need it when running our program.</li>\n</ol>\n<h4 id=\"connecting-to-the-database-programmatically---dbts\">Connecting to the Database programmatically - <code>db.ts</code></h4>\n<p>In the <code>db.js</code> file, we will import <code>mongoose</code> and then define a new schema for the database - in our case, the only schema we will need is the user schema.</p>\n<br />\nWe will then create a new mongoose model that will be exported for use to query the database. Notice that we have set the `connectionString`\nvariable to an environment variable - this is safer than pasting the connection string right into your code because it makes your database vulnerable.\nIn our case, will set the connection string to an environment varible when we are ready to run the application.\n\n<pre><code class=\"language-ts\">import mongoose from &#39;mongoose&#39;\nconst Schema = mongoose.Schema\n\n// @ts-ignore\nconst connectionString: String = process.env.MONGO_DB\n// @ts-ignore\nmongoose.connect(connectionString, {\n  useNewUrlParser: true,\n  useUnifiedTopology: true,\n  useFindAndModify: false,\n  useCreateIndex: true\n})\n\nconst UserSchema = new Schema({\n  name: String,\n  username: String\n})\n\nconst User = mongoose.model(&#39;User&#39;, UserSchema)\n\nexport { User }\n</code></pre>\n<h3 id=\"declaring-the-resolvers---resolversts\">Declaring the resolvers - <code>resolvers.ts</code></h3>\n<p>The resolvers are the functions that are run whenever the endpoint is run - so you need to define a function for each query and mutation as we will do below:</p>\n<pre><code class=\"language-ts\">import { UserType } from &#39;./types&#39;\n\n// import the User from the database\nimport { User } from &#39;./db&#39;\n\nexport const resolvers = {\n  Query: {\n    //@ts-ignore\n    getUser: (root, { username }) =&gt; {\n      return User.findOne({ username: username })\n        .then((user: UserType) =&gt; {\n          return user\n        })\n        .catch((error: any) =&gt; {\n          console.log(error.message)\n        })\n    }\n  },\n  Mutation: {\n    // @ts-ignore\n    createUser: async (root, { user }) =&gt; {\n      const newUser = new User({ name: user.name, username: user.username })\n      await newUser.save()\n      return newUser\n    }\n  }\n}\n</code></pre>\n<h2 id=\"piece-the-pie-together-ü•ß---indexts\">Piece the pie together ü•ß - <code>index.ts</code></h2>\n<p>Our <code>index.ts</code> file is where all the majic happens. We will begin by importing the necessary packages and instantiating a new express app. Then we will initialize the connection to the database and attach the <code>grapqlHTTP</code> middleware function with our schema and <code>graphiql</code> - which we can use to explore the api:</p>\n<pre><code class=\"language-ts\">import express from &#39;express&#39;\nimport { graphqlHTTP } from &#39;express-graphql&#39;\nimport { schema } from &#39;./data/schema&#39;\n\n// Initialize app\nconst app = express()\nrequire(&#39;./data/db&#39;)\n\n// the graphQL endpoint at /graphql.\napp.use(&#39;/graphql&#39;, graphqlHTTP({ schema: schema, graphiql: true }))\n\napp.get(&#39;*&#39;, (req, res) =&gt; {\n  res.json({ message: &#39;Welcome to the api&#39; })\n})\n\nconst PORT = 7000\napp.listen(PORT, () =&gt; {\n  console.log(`api is running on port ${PORT}`)\n})\n</code></pre>\n<h2 id=\"running-the-server\">Running the server</h2>\n<p>Before we run the server, we will need to add our mongoDB connection string to the environment variables:</p>\n<pre><code class=\"language-bash\">  export MONGO_DB=&#39;mongodb+srv://amani:AEDPfTeq61WH04NL@cluster0.9ntf0.mongodb.net/bliss?retryWrites=true&amp;w=majority&#39;\n</code></pre>\n<p>Now, we are ready to run the server üöÄ</p>\n<pre><code class=\"language-bash\">  npm run start\n</code></pre>\n<p>And we can run the server and explore our api.\nHere&#39;s an example of a mutation that you can make with the api:</p>\n<h3 id=\"mutation\">Mutation</h3>\n<p>We can add a user by making a mutation on the api:</p>\n<pre><code class=\"language-txt\">  mutation createUser ($input:UserInput){\n    createUser(user:$input) {\n      name\n      username\n    }\n  }\n</code></pre>\n<p>We can then pass in the user input using the query variables:</p>\n<pre><code class=\"language-txt\">  {\n    &quot;input&quot;: {\n      &quot;name&quot;: &quot;Laurence&quot;,\n      &quot;username&quot;: &quot;laudebugs&quot;\n    }\n  }\n</code></pre>\n<p>Here&#39;s how the mutation looks like:</p>\n<p>&lt;img src={&#39;<a href=\"https://raw.githubusercontent.com/lbugasu/articles/main/resources/graphqlmutation.png&#39;%7D\">https://raw.githubusercontent.com/lbugasu/articles/main/resources/graphqlmutation.png&#39;}</a> width={&#39;100%&#39;} /&gt;</p>\n<h3 id=\"query\">Query</h3>\n<p>If we were to then ask the api for a certain user, we can make the query by:</p>\n<pre><code class=\"language-txt\">  query {\n    getUser (username:&quot;laudebugs&quot;){\n      name\n    }\n  }\n</code></pre>\n<p>You can check out the <a href=\"https://github.com/lbugasu/express-gql-api\">repo here</a></p>\n<h3 id=\"common-issues-that-you-may-run-into\">Common Issues that you may run into:</h3>\n<ol>\n<li><strong>IP isn&#39;t whitelisted</strong>: If you&#39;re running into this issue, it may be the case that your ip address has changed and you need to add your current IP to be able to connect.</li>\n<li><strong>Could not find a declaration file for &#39;express&#39;</strong>\nInstall the declaratio file for <code>express</code>:</li>\n</ol>\n<pre><code class=\"language-bash\">    npm i --save-dev express\n</code></pre>\n<h2 id=\"further-reading\">Further Reading</h2>\n<ul>\n<li><a href=\"https://medium.com/atheros/graphql-quick-tip-how-to-pass-variables-into-a-mutation-in-graphiql-23ecff4add57\">GraphQL quick tip: How to pass variables in GraphiQL</a></li>\n</ul>\n]]></content>\n        <author>\n            <name>Laurence B. Ininda</name>\n            <email>lbugasu@gmail.com</email>\n            <uri>https://www.laudebugs.me/</uri>\n        </author>\n        <contributor>\n            <name>Laurence B. Ininda</name>\n            <email>lbugasu@gmail.com</email>\n            <uri>https://www.laudebugs.me/</uri>\n        </contributor>\n    </entry>\n    <entry>\n        <title type=\"html\"><![CDATA[Kenya Web Project]]></title>\n        <id>https://www.laudebugs.me/dev/kenya-web-project</id>\n        <link href=\"https://www.laudebugs.me/dev/kenya-web-project\"/>\n        <updated>2020-06-05T00:00:00.000Z</updated>\n        <summary type=\"html\"><![CDATA[Examining performance and data download sizes of Kenya's top 500 websites. Expecially in emerging markets, website developers need to build small and efficient web applications.]]></summary>\n        <content type=\"html\"><![CDATA[<h2 id=\"foreground\">Foreground</h2>\n<p>The internet is a vast ‚Äúland‚Äù with plenty of room to create, share and find content. Internet usage in Kenya is increasing by the year. COVID-19 brought to the forefront, the importance of having an online presence. Companies like Amazon, that were internet-first, widened their market share of internet sales and became more relevant. Those companies that didn‚Äôt have an online presence realized that they needed to adapt quickly to the times. Even people realized that they needed to build an online presence to showcase their work or seek jobs.</p>\n<p>In developing countries like Kenya, with companies shifting online, there is a growing need to track these trends. However, data is still expensive for the average Kenyan even though data consumption in the country has been increasing by the year. Therefor, in as much as companies are moving online, they need to take into consideration this very fact that accessing websites should not require a large amount of data ‚Äì say more than 2MB (to be revised later). And web developers need to be creative in ways that they can reduce data consumption on subsequent website visits to the sites they build. For instance, through caching or giving users a low-data version of their site once they land on the page before loading any subsequent content.</p>\n<h2 id=\"conceptualization\">Conceptualization</h2>\n<p>Through¬†this¬†project,¬†I¬†would¬†like¬†to¬†accomplish¬†two¬†things:</p>\n<ul>\n<li>Create¬†a¬†directory¬†of¬†Kenyan¬†websites - websites¬†with¬†extensions¬†‚Äú.co.ke‚Äù¬†or¬†‚Äú.ke‚Äù or that include¬†‚Äúkenya‚Äù¬†within the domain¬†name.</li>\n<li>Of¬†the¬†collected¬†sites,¬†note¬†how¬†much¬†data¬†is¬†downloaded¬†on¬†the¬†landing¬†page of¬†the site¬†and¬†organize¬†this¬†data¬†into¬†a¬†repository.</li>\n</ul>\n<h2 id=\"data-collection-and-preparation\">Data Collection and Preparation</h2>\n<p>How many websites can I find by randomly searching common words and the big companies in Kenya?</p>\n<p>After considering this, I searched the internet to try to find a difinitive list of websites in Kenya. To find this list, I would have to contact organizations like The Kenya Network Information Centre (KENIC) to obtain this information. And although this seemed like the route to go, I also found a list of the top 500 websites in Kenya provided by Alexa and figured that this list would be more useful to use as a baseline of websites in Kenya. And as the list showed, there&#39;s a large number of domains that do not end with .co.ke or .ke that Kenyans use. After signing up for the free trial, I parsed the data to this json file using a simple java script.</p>\n<p>Considering all the information that lighthouse provided, two metrics seemed important: the performance of the site as well as the amount of data downloaded when a user accesses the website., i.e. Total size.\nTwo metrics: Performance and total size downloaded on page load\nThe size will vary from device to device since mobile devices might have cached the websites before or CDN&#39;s might be used to deliver a faster and smaller payload.</p>\n<h3 id=\"why-lighthouse\">Why lighthouse?</h3>\n<p>Google provides Lighthouse as a developer tool to generate a report on a website. The tool is also available as a commandline interface tool. However, I wanted to use the tool as part of a node.js project. Therefore, I stumbled on this project by Sahava on github from which I borrowed heavily and modified to my own use.\nGenerating¬†the¬†Reports</p>\n<p>Since my computer crawled at even the thought of running lighthouse on 500 websites, I decided to run the runLightHouse.js script on AWS.\nHere are the steps for creating an AWS instance:\nAfter Creating an Amazon AWS account,\nCreate an EC2 instance. You can proceed with launching an instance that contains the free tier.</p>\n<pre><code>Launch instance &gt; Ubuntu 20.04 (with Free tier eligible) &gt; General Purpose Instance Type &gt; Choose an Existing Key-pair for ssh into your instance or download a new instance &gt;Launch instance\n</code></pre>\n<p>I however created an instance type with a GPU (just for fun) and to perform lighthouse processes fast. (this cost a couple of cents/hr)\nSSH into your instance:</p>\n<pre><code class=\"language-bash\"># move your .pem file into the come folder\n# Assuming you downloaded the .pem file to the downloads folder:\n# cd into the root directory\ncd\n# check whether a .ssh folder exists\nls -al\n# if it doesn&#39;t, create the folder\nmkdir .ssh\n#move the .pem file into the .ssh folder. Here assume I call my .pem file myKeyPair\nmv [path where the .pem file exists]/myKeyPair.pem myKeyPair.pem\n# change the permissions of the .pem file\nchmod 400 .ssh/myKeyPair.pem\n</code></pre>\n<p>Copy your Public DNS (IPv4) from your AWS instance - this is usually located at your instances page when you click on your instance</p>\n<p>SSH into your instance</p>\n<pre><code class=\"language-bash\"># replace [my public ip with the actual ip]\nssh -i ~/.ssh/myKeyPair.pem ubuntu@[Public DNS (IPv4)]\n# you may be asked whether to type yes or no to proceed. Type yes to proceed\n\n# Prepare the server to run your script\ninstall git\nsudo apt install git -y\n# Install latest version of npm\ncurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash\nsudo apt-get install -y nodejs\n# Install Chrome. I referenced this article\n\n# Download Google chrome\nwget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\n# install google chrome\nsudo apt install ./google-chrome-stable_current_amd64.deb\n</code></pre>\n<h3 id=\"running-the-script\">Running the script</h3>\n<pre><code class=\"language-bash\"># Clone the repo\ngit clone https://github.com/lbugasu/kenya-web-project.git\n\n# enter project folder\ncd kenya-web-project\n\n# Install packages\nnpm i\n\n# Run the script\nnode generateReports.js\n# Exit the AWS instance\n</code></pre>\n<h2 id=\"update\">Update</h2>\n<p>I tried running the script on an amazon linux server but there was always an error generated, so I switched to using an ubuntu 20.04 instance.\nBelow are the instructions fro setting up and to ssh into an Amazon linux ec2 instance:\nAfter Creating an Amazon AWS account,\nCreate an EC2 instance. You can proceed with launching an instance that contains the free tier.</p>\n<pre><code class=\"language-text\">Launch instance &gt; Amazon Linux (with Free tier eligible) &gt; General Purpose Instance Type &gt; Choose an Existing Key-pair for ssh into your instance or download a new instance &gt;Launch instance\n</code></pre>\n<p>I however created an instance type with a GPU (just for fun) and to perform lighthouse processes fast. (this cost a couple of cents/hr)\nSSH into your instance:</p>\n<pre><code class=\"language-bash\"># move your .pem file into the come folder\n# Assuming you downloaded the .pem file to the downloads folder:\n# cd into the root directory\ncd [root directory]\n\n# check whether a .ssh folder exists\nls -al\n\n# if it doesn&#39;t, create the folder\nmkdir .ssh\n#move the .pem file into the .ssh folder. Here assume I call my .pem file myKeyPair\nmv [path where the .pem file exists]/myKeyPair.pem myKeyPair.pem\n\nChange the permissions of the .pem file\n```bash\nchmod 400 .ssh/myKeyPair.pem\n</code></pre>\n<p>Copy your Public DNS (IPv4) from your AWS instance - this is usually located at your instances page when you click on your instance</p>\n<pre><code>SSH into your instance\n```bash\n# replace [my public ip with the actual ip]\nssh -i ~/.ssh/myKeyPair.pem ec2-user@[Public DNS (IPv4)]\n</code></pre>\n<p>You may be asked whether to type yes or no to proceed. Type yes to proceed</p>\n<pre><code class=\"language-bash\"># Prepare the server to run your script\n# install git\nsudo yum install git -y\n</code></pre>\n<p>install npm using Amazon&#39;s instructions</p>\n<pre><code class=\"language-bash\"># Install latest version of npm\nnpm install -g npm@latest\n# Install Chrome. I referenced this article\ncurl https://intoli.com/install-google-chrome.sh | bash\n</code></pre>\n<h4 id=\"running-the-script-1\">Running the script</h4>\n<pre><code class=\"language-bash\">#Clone the repo\ngit clone https://github.com/lbugasu/kenya-web-project.git\n\n# enter project folder\n```bash\ncd kenya-web-project\n# Install packages\nnpm i\n# Exit the AWS instance\nexit\n</code></pre>\n<h2 id=\"analysis\">Analysis</h2>\n<p>Having obtained two additional metrics of each website, i.e. the performance and size of page downloaded, then we can plot several graphs to gauge how one metric affects the other.</p>\n<p>In order to answer questions that the data presented, there still remained missing pieces of information that would enable me to analyze the data accurately. With metrics such as performance, size of webpage downloaded and average time spent on a website, we could take a look at the general trend of the top websites in Kenya as shown below.</p>\n<p>&lt;img\n  alt=&quot;Size of the web page downloaded&quot;\n  src={&#39;<a href=\"https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/Size%20of%20the%20web%20page%20downloaded.png&#39;%7D\">https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/Size%20of%20the%20web%20page%20downloaded.png&#39;}</a>\n  width={&#39;100%&#39;}\n/&gt;</p>\n<p>The optimal size of a web page is 0 - 1 MB downloaded once a use logs onto a site. This is of course, not taking into account cached resources that might reduce the size of the page downloaded.</p>\n<p>&lt;img\n  alt=&quot;TimeSpentOnWebsite&quot;\n  src={&#39;<a href=\"https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/TimeSpentOnWebsite.png&#39;%7D\">https://raw.githubusercontent.com/lbugasu/kenya-web-project/master/analysis/graphs/TimeSpentOnWebsite.png&#39;}</a>\n  width={&#39;100%&#39;}\n/&gt;</p>\n<p>The modal time spent on a website by Kenyans is 3 minutes with the average coming to 7.2682 minutes.</p>\n<h2 id=\"postscript\">Postscript</h2>\n<p>In analyzing the dataset, there&#39;s a temptation to draw immediate conclusions from the various datapoints such as comparing the time spent and how this changes based on the size of the web page downloaded when a user accesses the website. However, this analysis doesn&#39;t take into account the fact that different websites serve different functions. For instance, a person logging into the Kenya Revenue Authority website would perhaps use the site for a specific predetermined use case while a person using YouTube might not have a goal in mind while using the site. And therefore one would need to make assumptions to immediately draw conclusions from the data. On modelling the graph, the size of the page downloaded doesn&#39;t relate to how much time is spent on the site.\nFurther information is needed to ask deeper questions from the dataset. One such piece is the genre of the website which would be able to draw distinctions between the different websites and make comparisons within websites of a certain type.\nAs of now, the dataset is freely available to use and for more research to be done. Especially at a time when the internet is crucial to keep systems moving during Covid-19, we need to examine more closely how Kenyans use the internet.\nHiccups along the way\nIn generating the lighthouse reports for the site, I decided to splice the list of websites into groups of 30 websites at a time - because even AWS servers weren&#39;t running all the reports smoothly. At other times, I ran 50 reports at a time. However, while doing this, I realised I skipped over close to 70 websites spread over my input set of 500. And so, I wrote a small python script to find the missing sites.\nI had to manually run the website Bet365.com using the lighthouse cli because the node script kept timing out</p>\n<h3 id=\"after-installing-lighthouse\">After installing lighthouse</h3>\n<p><code>npm install -g lighthouse</code></p>\n<pre><code class=\"language-bash\">lighthouse https://www.bet365.com/ --quiet --output json --output-path ./www_Bet365_com.json\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/sahava/multisite-lighthouse\">Multisite Lighthouse</a></li>\n<li><a href=\"https://www.alexa.com/topsites/countries/KE\">Top Sites in Kenya</a></li>\n<li>Google Chrome Lighthouse <a href=\"https://github.com/GoogleChrome/lighthouse\">Github Repository</a></li>\n</ul>\n<p>-&gt; Checkout the <a href=\"https://github.com/lbugasu/kenya-web-project\">Github Repository</a></p>\n]]></content>\n        <author>\n            <name>Laurence B. Ininda</name>\n            <email>lbugasu@gmail.com</email>\n            <uri>https://www.laudebugs.me/</uri>\n        </author>\n        <contributor>\n            <name>Laurence B. Ininda</name>\n            <email>lbugasu@gmail.com</email>\n            <uri>https://www.laudebugs.me/</uri>\n        </contributor>\n    </entry>\n</feed>"
}